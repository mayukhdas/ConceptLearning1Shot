% Running on host: DESKTOP-K98RL7C

% Creating string handler #1.


% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=0: args[N]=.\Blocks\train/train_pos.txt

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=1: args[N]=.\Blocks\train/train_neg.txt

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=2: args[N]=.\Blocks\train/train_bk.txt

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=3: args[N]=.\Blocks\train/train_facts.txt

% Welcome to the WILL ILP/SRL systems.


% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.
% Reading background theory from dir: null
% Load '../blocks_bk.txt'.

% Switching to VarIndicator = uppercase.

***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****


***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****


***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****

% LoadAllModes() called.  Currently loaded modes: []
% LoadAllLibraries() called.  Currently loaded libraries: [listsInLogic, differentInLogic, modes_listsInLogic, modes_differentInLogic, comparisonInLogic, bootstrapBKinLogic, modes_arithmeticInLogic, inlines_comparisonInLogic, inlines_differentInLogic, arithmeticInLogic, inlines_listsInLogic, modes_comparisonInLogic, inlines_arithmeticInLogic]

%  Read the facts.
%  Have read 12 facts.
% Have read 1 examples from '.\Blocks\train' [.\Blocks\train/train*].
% Have read 0 examples from '.\Blocks\train' [.\Blocks\train/train*].

%  LearnOneClause initialized.

***** Warning: % Should not set minPosCoverage (2.0) to more than the total weight on the positive examples (1.0).  Will use the maximum possible value. *****

% Reading background theory from dir: .\Blocks\train
% Have read the relevance files.


% NEW target:                 Ell(D)
%  targetPred:                Ell/1
%  targetArgTypes:            signature = [const], types = [+Shape]
%  targets:                   [Ell(D)]
%  targetPredicates:          [Ell/1]
%  targetArgSpecs:            [[D[+Shape]]]
%  variablesInTargets:        [[D]]

% Started collecting constants

% Collecting the types of constants.

% Looking at the training examples to see if any types of new constants can be inferred.
% Time to collect constants: 2 milliseconds
% Time to collect examples: 0 seconds

% Read 1 pos examples and 0 neg examples.
% Time to init learnOneClause: 20 milliseconds

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr0(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd1(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice4(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice4(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice5(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice5(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #1: Duplicate cost of 'single_piece_advice5/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #2: Duplicate cost of 'mega_notPosAnd_negAnd1/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #3: Duplicate cost of 'not_single_example_advice4/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #4: Duplicate cost of 'mega_posAnd_notNegOr0/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #5: Duplicate cost of 'single_example_advice4/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #6: Duplicate cost of 'not_single_piece_advice5/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr6(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd7(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice10(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice10(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice11(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice11(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #7: Duplicate cost of 'mega_posAnd_notNegOr6/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #8: Duplicate cost of 'single_piece_advice11/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #9: Duplicate cost of 'not_single_piece_advice11/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #10: Duplicate cost of 'mega_notPosAnd_negAnd7/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #11: Duplicate cost of 'single_example_advice10/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #12: Duplicate cost of 'not_single_example_advice10/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.


% LearnOneClause Parameters:
%   Targets (1):
%    Ell(+Shape)
%  Modes (48):
%    Row(+part1),
%    Length(+part1, #Float),
%    Column(+part2),
%    Height(+Shape, #Float),
%    Contains(+Shape, -part1, -part2),
%    Base(+Shape, #Float),
%    addList(+willList, #willNumber),
%    multiplyList(+willList, #willNumber),
%    abs(+willNumber, &willNumber),
%    minus(+willNumber, &willNumber),
%    minus(+willNumber, +willNumber, &willNumber),
%    plus(+willNumber, +willNumber, &willNumber),
%    mult(+willNumber, +willNumber, &willNumber),
%    div(+willNumber, +willNumber, &willNumber),
%    allNumbers(+willList),
%    positiveNumber(+willNumber),
%    negativeNumber(+willNumber),
%    in0toDot001(+willNumber),
%    in0toDot01(+willNumber),
%    in0toDot1(+willNumber),
%    in0to1(+willNumber),
%    in0to10(+willNumber),
%    in0to100(+willNumber),
%    in0to1000(+willNumber),
%    equalWithTolerance(+willNumber, +willNumber, &willNumber),
%    greaterOrEqualDifference(+willNumber, +willNumber, &willNumber),
%    smallerOrEqualDifference(+willNumber, +willNumber, &willNumber),
%    isaEqualTolerance(+willNumber),
%    lessThan(+willNumber, +willNumber),
%    greaterThan(+willNumber, +willNumber),
%    lessThanOrEqual(+willNumber, +willNumber),
%    greaterThanOrEqual(+willNumber, +willNumber),
%    inBetweenOO(+willNumber, +willNumber, +willNumber),
%    inBetweenCO(+willNumber, +willNumber, +willNumber),
%    inBetweenOC(+willNumber, +willNumber, +willNumber),
%    inBetweenCC(+willNumber, +willNumber, +willNumber),
%    memberOfList(+willAnything, +willList),
%    firstInList(+willList, &willAnything),
%    restOfList(+willList, &willList),
%    positionInList(+willAnything, +willList, &willNumber),
%    nthInList(+willNumber, +willList, &willAnything),
%    lengthOfList(+willList, &willNumber),
%    mega_posAnd_notNegOr6(+Shape),
%    single_piece_advice11(+Shape),
%    not_single_piece_advice11(+Shape),
%    mega_notPosAnd_negAnd7(+Shape),
%    single_example_advice10(+Shape),
%    not_single_example_advice10(+Shape)

% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.46s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% [Onion] Generating advice to determine onion levels.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr12(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd13(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice16(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice16(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice17(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice17(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% [Onion] Advice generation and checking complete (9.00ms).
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = single_piece_advice5/1 Relevant: single_piece_advice5/1 strength=STRONGLY_RELEVANT
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = not_single_example_advice4/1 Relevant: not_single_example_advice4/1 strength=VERY_STRONGLY_RELEVANT_NEG
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = mega_posAnd_notNegOr6/1 Relevant: mega_posAnd_notNegOr6/1 strength=POSSIBLE_ANSWER
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = not_single_piece_advice11/1 Relevant: not_single_piece_advice11/1 strength=STRONGLY_RELEVANT_NEG
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = mega_notPosAnd_negAnd1/1 Relevant: mega_notPosAnd_negAnd1/1 strength=POSSIBLE_ANSWER
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = mega_posAnd_notNegOr0/1 Relevant: mega_posAnd_notNegOr0/1 strength=POSSIBLE_ANSWER
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = not_single_piece_advice5/1 Relevant: not_single_piece_advice5/1 strength=STRONGLY_RELEVANT_NEG
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = mega_notPosAnd_negAnd7/1 Relevant: mega_notPosAnd_negAnd7/1 strength=POSSIBLE_ANSWER
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = single_example_advice10/1 Relevant: single_example_advice10/1 strength=VERY_STRONGLY_RELEVANT
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = not_single_example_advice10/1 Relevant: not_single_example_advice10/1 strength=VERY_STRONGLY_RELEVANT_NEG
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = single_example_advice4/1 Relevant: single_example_advice4/1 strength=VERY_STRONGLY_RELEVANT
% setDefaultParameterSettingsToConsider: Have IGNORED (possibly because no mode has been defined) this relevance literal = single_piece_advice11/1 Relevant: single_piece_advice11/1 strength=STRONGLY_RELEVANT
% havePossibleAnswer     = true
% haveStrongestRelevance = true
% haveRelevance          = false
% haveMildestRelevance   = false
% haveNeutralRelevance   = true
% haveIrrelevance        = false
% setMinF1toStop = 0.9891089108910891
%   Add combo #1.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.99)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #2.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(1)/MaxClauses(1)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #3.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.99)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #4.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(3)/MaxClauses(1)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #5.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.99)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #6.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(7)/MaxClauses(1)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #7.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(3)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.14)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #8.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(1)/MaxClauses(3)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #9.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(3)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.14)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #10.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(3)/MaxClauses(3)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #11.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(3)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.14)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #12.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(7)/MaxClauses(3)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #13.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(15)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.10)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #14.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(1)/MaxClauses(15)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #15.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(15)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.10)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #16.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(3)/MaxClauses(15)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
% setMinF1toStop = 0.9891089108910891
%   Add combo #17.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(15)/MinPrec(0.9891)/MaxExpands(10)/MaxCreates(101)/MinPos(0.10)/MaxNegs(-1.00)
% setMinF1toStop = 0.0
%   Add combo #18.
%     MinRelevance(POSSIBLE_ANSWER)/Flipped(true)/MaxLen(7)/MaxClauses(15)/MinPrec(0.0000)/MaxExpands(10)/MaxCreates(200)/MinPos(0.00)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #19.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #20.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #21.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #22.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #23.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #24.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #25.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #26.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #27.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #28.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #29.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #30.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #31.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #32.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #33.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #34.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #35.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #36.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #37.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #38.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #39.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #40.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #41.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #42.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #43.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #44.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #45.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #46.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #47.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #48.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #49.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #50.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #51.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #52.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #53.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #54.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #55.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #56.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #57.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #58.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #59.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #60.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(10)/MaxCreates(101)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #61.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #62.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #63.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #64.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #65.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #66.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(100)/MaxCreates(1017)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #67.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #68.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #69.
%     MinRelevance(POSSIBLE_ANSWER)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 1001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #70.
%     MinRelevance(null)/MaxLen(1)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 3001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #71.
%     MinRelevance(null)/MaxLen(3)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)
%  setPreviousMinPrecision: for key = 7001, oldValue = 0.9891089108910891 and newValue = 0.9823529411764705 but these should not be different.
% setMinF1toStop = 0.9823529411764705
%   Add combo #72.
%     MinRelevance(null)/MaxLen(7)/MaxClauses(1)/MinPrec(0.9824)/MaxExpands(1000)/MaxCreates(10176)/MinPos(0.98)/MaxNegs(-1.00)

% Have 72 Onion combinations to try.
LAYERS ################## 72

%----------------------------
% CONSIDERING Settings #0 (1 of 72).
% (The ONION has been running for a total of 70.00ms
%  and has 12.00h left;
%  36.00m have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr12(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd13(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice16(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice16(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice17(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice17(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #13: Duplicate cost of 'single_piece_advice17/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #14: Duplicate cost of 'not_single_piece_advice17/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #15: Duplicate cost of 'mega_posAnd_notNegOr12/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #16: Duplicate cost of 'not_single_example_advice16/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #17: Duplicate cost of 'single_example_advice16/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #18: Duplicate cost of 'mega_notPosAnd_negAnd13/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr18(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd19(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice22(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice22(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice23(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice23(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #19: Duplicate cost of 'not_single_piece_advice23/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #20: Duplicate cost of 'mega_notPosAnd_negAnd19/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #21: Duplicate cost of 'single_example_advice22/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #22: Duplicate cost of 'single_piece_advice23/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #23: Duplicate cost of 'mega_posAnd_notNegOr18/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #24: Duplicate cost of 'not_single_example_advice22/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.05s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (2 of 72).
% (The ONION has been running for a total of 135.00ms
%  and has 12.00h left;
%  36.00m have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr24(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd25(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice28(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice28(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice29(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice29(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #25: Duplicate cost of 'mega_posAnd_notNegOr24/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #26: Duplicate cost of 'single_piece_advice29/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #27: Duplicate cost of 'not_single_piece_advice29/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #28: Duplicate cost of 'not_single_example_advice28/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #29: Duplicate cost of 'single_example_advice28/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #30: Duplicate cost of 'mega_notPosAnd_negAnd25/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr30(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd31(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice34(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice34(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice35(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice35(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #31: Duplicate cost of 'mega_notPosAnd_negAnd31/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #32: Duplicate cost of 'single_example_advice34/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #33: Duplicate cost of 'not_single_piece_advice35/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #34: Duplicate cost of 'mega_posAnd_notNegOr30/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #35: Duplicate cost of 'not_single_example_advice34/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #36: Duplicate cost of 'single_piece_advice35/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.03s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (3 of 72).
% (The ONION has been running for a total of 164.00ms
%  and has 12.00h left;
%  36.00m have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr36(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd37(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice40(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice40(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice41(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice41(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #37: Duplicate cost of 'mega_posAnd_notNegOr36/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #38: Duplicate cost of 'not_single_example_advice40/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #39: Duplicate cost of 'single_example_advice40/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #40: Duplicate cost of 'single_piece_advice41/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #41: Duplicate cost of 'not_single_piece_advice41/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #42: Duplicate cost of 'mega_notPosAnd_negAnd37/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr42(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd43(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice46(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice46(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice47(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice47(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #43: Duplicate cost of 'mega_notPosAnd_negAnd43/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #44: Duplicate cost of 'single_example_advice46/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #45: Duplicate cost of 'mega_posAnd_notNegOr42/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #46: Duplicate cost of 'not_single_piece_advice47/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #47: Duplicate cost of 'not_single_example_advice46/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #48: Duplicate cost of 'single_piece_advice47/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.03s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (4 of 72).
% (The ONION has been running for a total of 196.00ms
%  and has 12.00h left;
%  40.00m have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr48(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd49(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice52(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice52(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice53(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice53(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #49: Duplicate cost of 'mega_posAnd_notNegOr48/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #50: Duplicate cost of 'single_piece_advice53/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #51: Duplicate cost of 'not_single_piece_advice53/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #52: Duplicate cost of 'mega_notPosAnd_negAnd49/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #53: Duplicate cost of 'not_single_example_advice52/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #54: Duplicate cost of 'single_example_advice52/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr54(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd55(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice58(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice58(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice59(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice59(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #55: Duplicate cost of 'single_example_advice58/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #56: Duplicate cost of 'mega_posAnd_notNegOr54/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #57: Duplicate cost of 'not_single_piece_advice59/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #58: Duplicate cost of 'not_single_example_advice58/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #59: Duplicate cost of 'single_piece_advice59/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #60: Duplicate cost of 'mega_notPosAnd_negAnd55/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (5 of 72).
% (The ONION has been running for a total of 224.00ms
%  and has 12.00h left;
%  50.00m have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr60(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd61(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice64(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice64(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice65(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice65(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #61: Duplicate cost of 'mega_notPosAnd_negAnd61/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #62: Duplicate cost of 'mega_posAnd_notNegOr60/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #63: Duplicate cost of 'single_piece_advice65/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #64: Duplicate cost of 'not_single_piece_advice65/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #65: Duplicate cost of 'not_single_example_advice64/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #66: Duplicate cost of 'single_example_advice64/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr66(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd67(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice70(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice70(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice71(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice71(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #67: Duplicate cost of 'not_single_example_advice70/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #68: Duplicate cost of 'single_piece_advice71/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #69: Duplicate cost of 'mega_posAnd_notNegOr66/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #70: Duplicate cost of 'single_example_advice70/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #71: Duplicate cost of 'not_single_piece_advice71/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #72: Duplicate cost of 'mega_notPosAnd_negAnd67/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (6 of 72).
% (The ONION has been running for a total of 243.00ms
%  and has 12.00h left;
%  0.00y have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr72(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd73(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice76(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice76(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice77(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice77(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #73: Duplicate cost of 'mega_notPosAnd_negAnd73/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #74: Duplicate cost of 'mega_posAnd_notNegOr72/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #75: Duplicate cost of 'single_piece_advice77/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #76: Duplicate cost of 'not_single_piece_advice77/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #77: Duplicate cost of 'single_example_advice76/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #78: Duplicate cost of 'not_single_example_advice76/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr78(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd79(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice82(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice82(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice83(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice83(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #79: Duplicate cost of 'not_single_example_advice82/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #80: Duplicate cost of 'mega_posAnd_notNegOr78/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #81: Duplicate cost of 'single_piece_advice83/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #82: Duplicate cost of 'single_example_advice82/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #83: Duplicate cost of 'mega_notPosAnd_negAnd79/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #84: Duplicate cost of 'not_single_piece_advice83/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.03s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (7 of 72).
% (The ONION has been running for a total of 279.00ms
%  and has 12.00h left;
%  1.17h have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr84(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd85(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice88(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice88(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice89(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice89(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #85: Duplicate cost of 'mega_notPosAnd_negAnd85/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #86: Duplicate cost of 'not_single_piece_advice89/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #87: Duplicate cost of 'mega_posAnd_notNegOr84/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #88: Duplicate cost of 'single_example_advice88/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #89: Duplicate cost of 'single_piece_advice89/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #90: Duplicate cost of 'not_single_example_advice88/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr90(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd91(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice94(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice94(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice95(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice95(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #91: Duplicate cost of 'not_single_example_advice94/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #92: Duplicate cost of 'single_piece_advice95/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #93: Duplicate cost of 'mega_notPosAnd_negAnd91/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #94: Duplicate cost of 'single_example_advice94/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #95: Duplicate cost of 'mega_posAnd_notNegOr90/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #96: Duplicate cost of 'not_single_piece_advice95/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.06s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (8 of 72).
% (The ONION has been running for a total of 341.00ms
%  and has 12.00h left;
%  1.33h have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr96(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd97(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice100(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice100(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice101(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice101(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #97: Duplicate cost of 'mega_notPosAnd_negAnd97/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #98: Duplicate cost of 'single_example_advice100/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #99: Duplicate cost of 'single_piece_advice101/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr102(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd103(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice106(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice106(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice107(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice107(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (9 of 72).
% (The ONION has been running for a total of 357.00ms
%  and has 12.00h left;
%  1.50h have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr108(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd109(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice112(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice112(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice113(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice113(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr114(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd115(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice118(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice118(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice119(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice119(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

%----------------------------
% CONSIDERING Settings #0 (10 of 72).
% (The ONION has been running for a total of 366.00ms
%  and has 12.00h left;
%  1.67h have been allotted for this setting)
%  The differences from the default settings are:
%   modes in use: null
%   all modes:    null
% ILPparameterSettings.helpRun: annotationForSetting = null

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr120(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd121(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice124(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice124(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice125(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice125(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr126(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd127(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice130(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice130(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice131(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice131(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.909090): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.909

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.

% Cross-validation results for
%  The differences from the default settings are:
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]

 
% Clauses:

Ell(A) :- true. // Clause #1.


 % Folds = 1, Train: % [TP=1, FP=0, TN=0, FN=0, A=0.83, P=0.91, R=0.91, F1=0.91]
% precision = NaN vs cv min = 0.990
% recall    = NaN vs cv min = 0.990
% accuracy  = NaN vs cv min = 0.990
% F1        = NaN vs cv min = 0.990

***** Warning: 
% Nothing acceptable was found using the provided parameters and the time allowed, so giving it the ol' college try. *****


% RECONSIDERING Setting #1 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #1, minPrec=0.99, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr132(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd133(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr136(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd137(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #1 led to nothing being learned.

% RECONSIDERING Setting #2 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #2, flipped, minPrec=0.00, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd140(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd141(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #2 led to nothing being learned.

% RECONSIDERING Setting #3 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #3, minPrec=0.99, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr144(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd145(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr148(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd149(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #3 led to nothing being learned.

% RECONSIDERING Setting #4 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #4, flipped, minPrec=0.00, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd152(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd153(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #4 led to nothing being learned.

% RECONSIDERING Setting #5 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #5, minPrec=0.99, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr156(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd157(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr160(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd161(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #5 led to nothing being learned.

% RECONSIDERING Setting #6 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #6, flipped, minPrec=0.00, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd164(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd165(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #6 led to nothing being learned.

% RECONSIDERING Setting #7 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 6
%   maxNumberOfClauses = 3
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #7, minPrec=0.99, maxC=3, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr168(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd169(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr172(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd173(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #7 led to nothing being learned.

% RECONSIDERING Setting #8 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 6
%   maxNumberOfClauses = 3
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #8, flipped, minPrec=0.00, maxC=3, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd176(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd177(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #8 led to nothing being learned.

% RECONSIDERING Setting #9 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 6
%   maxNumberOfClauses = 3
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #9, minPrec=0.99, maxC=3, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr180(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd181(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr184(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd185(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #9 led to nothing being learned.

% RECONSIDERING Setting #10 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 6
%   maxNumberOfClauses = 3
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #10, flipped, minPrec=0.00, maxC=3, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd188(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd189(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #10 led to nothing being learned.

% RECONSIDERING Setting #11 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 6
%   maxNumberOfClauses = 3
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #11, minPrec=0.99, maxC=3, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr192(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd193(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr196(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd197(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #11 led to nothing being learned.

% RECONSIDERING Setting #12 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 6
%   maxNumberOfClauses = 3
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #12, flipped, minPrec=0.00, maxC=3, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd200(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd201(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #12 led to nothing being learned.

% RECONSIDERING Setting #13 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 30
%   maxNumberOfClauses = 15
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #13, minPrec=0.99, maxC=15, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr204(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd205(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr208(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd209(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #13 led to nothing being learned.

% RECONSIDERING Setting #14 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 30
%   maxNumberOfClauses = 15
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #14, flipped, minPrec=0.00, maxC=15, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd212(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd213(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #14 led to nothing being learned.

% RECONSIDERING Setting #15 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 30
%   maxNumberOfClauses = 15
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #15, minPrec=0.99, maxC=15, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr216(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd217(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr220(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd221(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #15 led to nothing being learned.

% RECONSIDERING Setting #16 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 30
%   maxNumberOfClauses = 15
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #16, flipped, minPrec=0.00, maxC=15, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd224(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd225(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #16 led to nothing being learned.

% RECONSIDERING Setting #17 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 30
%   maxNumberOfClauses = 15
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #17, minPrec=0.99, maxC=15, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr228(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd229(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr232(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd233(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #17 led to nothing being learned.

% RECONSIDERING Setting #18 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   positive and negative examples are flip-flopped
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 30
%   maxNumberOfClauses = 15
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #18, flipped, minPrec=0.00, maxC=15, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=200

% Initializing fold 0.
%   Number of positive TRAIN examples = 0.
%   Number of negative TRAIN examples = 1.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegAnd236(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd237(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER


% ******************************************

% Have stopped ILP's outer loop because have run out of seed positive examples to try.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 0 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 0 (out of 1) pos and 0 (out of 0) neg examples.

% % There are no clauses in this theory.
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% RECONSIDERING Setting #18 led to nothing being learned.

% RECONSIDERING Setting #19 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #19, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr240(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd241(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr244(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd245(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #19 led to nothing being learned.

% RECONSIDERING Setting #20 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #20, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr248(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd249(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr252(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd253(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.03s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #20 led to nothing being learned.

% RECONSIDERING Setting #21 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #21, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr256(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd257(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr260(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd261(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #21 led to nothing being learned.

% RECONSIDERING Setting #22 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #22, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr264(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd265(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice268(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice268(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice269(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice269(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr270(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd271(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice274(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice274(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice275(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice275(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #22 led to nothing being learned.

% RECONSIDERING Setting #23 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #23, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr276(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd277(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice280(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice280(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice281(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice281(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr282(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd283(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice286(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice286(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice287(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice287(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #23 led to nothing being learned.

% RECONSIDERING Setting #24 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #24, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr288(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd289(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice292(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice292(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice293(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice293(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr294(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd295(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice298(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice298(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice299(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice299(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #24 led to nothing being learned.

% RECONSIDERING Setting #25 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #25, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr300(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd301(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr304(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd305(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #25 led to nothing being learned.

% RECONSIDERING Setting #26 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #26, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr308(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd309(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr312(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd313(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #26 led to nothing being learned.

% RECONSIDERING Setting #27 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #27, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr316(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd317(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr320(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd321(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #27 led to nothing being learned.

% RECONSIDERING Setting #28 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #28, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr324(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd325(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice328(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice328(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice329(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice329(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr330(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd331(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice334(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice334(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice335(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice335(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.06s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #28 led to nothing being learned.

% RECONSIDERING Setting #29 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #29, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr336(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd337(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice340(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice340(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice341(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice341(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr342(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd343(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice346(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice346(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice347(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice347(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #29 led to nothing being learned.

% RECONSIDERING Setting #30 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #30, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr348(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd349(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice352(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice352(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice353(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice353(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr354(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd355(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice358(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice358(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice359(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice359(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #30 led to nothing being learned.

% RECONSIDERING Setting #31 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #31, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr360(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd361(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr364(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd365(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #31 led to nothing being learned.

% RECONSIDERING Setting #32 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #32, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr368(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd369(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr372(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd373(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #32 led to nothing being learned.

% RECONSIDERING Setting #33 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #33, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr376(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd377(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr380(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd381(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #33 led to nothing being learned.

% RECONSIDERING Setting #34 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #34, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr384(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd385(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice388(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice388(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice389(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice389(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr390(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd391(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice394(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice394(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice395(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice395(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #34 led to nothing being learned.

% RECONSIDERING Setting #35 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #35, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr396(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd397(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice400(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice400(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice401(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice401(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr402(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd403(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice406(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice406(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice407(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice407(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #35 led to nothing being learned.

% RECONSIDERING Setting #36 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #36, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr408(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd409(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice412(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice412(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice413(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice413(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr414(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd415(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice418(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice418(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice419(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice419(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #36 led to nothing being learned.

% RECONSIDERING Setting #37 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #37, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr420(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd421(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr424(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd425(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #37 led to nothing being learned.

% RECONSIDERING Setting #38 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #38, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr428(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd429(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr432(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd433(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #38 led to nothing being learned.

% RECONSIDERING Setting #39 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #39, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr436(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd437(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr440(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd441(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #39 led to nothing being learned.

% RECONSIDERING Setting #40 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #40, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr444(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd445(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice448(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice448(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice449(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice449(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr450(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd451(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice454(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice454(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice455(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice455(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #40 led to nothing being learned.

% RECONSIDERING Setting #41 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #41, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr456(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd457(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice460(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice460(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice461(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice461(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr462(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd463(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice466(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice466(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice467(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice467(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #41 led to nothing being learned.

% RECONSIDERING Setting #42 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #42, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr468(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd469(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice472(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice472(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice473(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice473(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr474(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd475(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice478(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice478(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice479(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice479(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.05s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #42 led to nothing being learned.

% RECONSIDERING Setting #43 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #43, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr480(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd481(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr484(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd485(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #43 led to nothing being learned.

% RECONSIDERING Setting #44 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #44, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr488(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd489(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr492(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd493(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #44 led to nothing being learned.

% RECONSIDERING Setting #45 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #45, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr496(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd497(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr500(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd501(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #45 led to nothing being learned.

% RECONSIDERING Setting #46 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #46, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr504(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd505(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice508(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice508(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice509(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice509(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr510(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd511(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice514(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice514(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice515(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice515(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #46 led to nothing being learned.

% RECONSIDERING Setting #47 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #47, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr516(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd517(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice520(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice520(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice521(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice521(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr522(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd523(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice526(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice526(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice527(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice527(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #47 led to nothing being learned.

% RECONSIDERING Setting #48 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #48, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr528(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd529(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice532(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice532(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice533(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice533(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr534(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd535(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice538(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice538(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice539(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice539(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #48 led to nothing being learned.

% RECONSIDERING Setting #49 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #49, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr540(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd541(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr544(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd545(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #49 led to nothing being learned.

% RECONSIDERING Setting #50 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #50, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr548(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd549(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr552(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd553(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #50 led to nothing being learned.

% RECONSIDERING Setting #51 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #51, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr556(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd557(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr560(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd561(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #51 led to nothing being learned.

% RECONSIDERING Setting #52 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #52, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr564(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd565(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice568(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice568(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice569(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice569(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr570(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd571(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice574(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice574(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice575(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice575(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #52 led to nothing being learned.

% RECONSIDERING Setting #53 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #53, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr576(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd577(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice580(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice580(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice581(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice581(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr582(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd583(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice586(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice586(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice587(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice587(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #53 led to nothing being learned.

% RECONSIDERING Setting #54 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #54, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr588(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd589(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice592(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice592(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice593(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice593(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr594(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd595(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice598(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice598(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice599(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice599(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #54 led to nothing being learned.

% RECONSIDERING Setting #55 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #55, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr600(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd601(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr604(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd605(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #55 led to nothing being learned.

% RECONSIDERING Setting #56 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #56, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr608(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd609(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr612(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd613(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #56 led to nothing being learned.

% RECONSIDERING Setting #57 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #57, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=101

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr616(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd617(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr620(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd621(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #57 led to nothing being learned.

% RECONSIDERING Setting #58 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #58, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr624(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd625(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice628(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice628(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice629(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice629(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr630(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd631(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice634(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice634(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice635(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice635(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #58 led to nothing being learned.

% RECONSIDERING Setting #59 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #59, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr636(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd637(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice640(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice640(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice641(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice641(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr642(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd643(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice646(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice646(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice647(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice647(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #59 led to nothing being learned.

% RECONSIDERING Setting #60 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #60, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr648(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd649(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice652(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice652(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice653(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice653(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr654(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd655(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice658(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice658(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice659(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice659(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #60 led to nothing being learned.

% RECONSIDERING Setting #61 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #61, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr660(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd661(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr664(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd665(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #61 led to nothing being learned.

% RECONSIDERING Setting #62 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #62, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr668(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd669(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr672(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd673(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #62 led to nothing being learned.

% RECONSIDERING Setting #63 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #63, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=1K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr676(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd677(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr680(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd681(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #63 led to nothing being learned.

% RECONSIDERING Setting #64 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #64, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr684(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd685(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice688(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice688(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice689(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice689(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr690(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd691(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice694(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice694(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice695(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice695(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #64 led to nothing being learned.

% RECONSIDERING Setting #65 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #65, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr696(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd697(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice700(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice700(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice701(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice701(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr702(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd703(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice706(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice706(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice707(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice707(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #65 led to nothing being learned.

% RECONSIDERING Setting #66 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #66, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr708(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd709(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice712(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice712(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice713(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice713(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr714(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd715(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice718(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice718(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice719(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice719(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #66 led to nothing being learned.

% RECONSIDERING Setting #67 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #67, minPrec=0.98, maxC=1, maxL=1, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr720(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd721(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr724(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd725(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #67 led to nothing being learned.

% RECONSIDERING Setting #68 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #68, minPrec=0.98, maxC=1, maxL=3, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr728(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd729(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr732(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd733(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.00s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #68 led to nothing being learned.

% RECONSIDERING Setting #69 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   minimum strength   = POSSIBLE_ANSWER
%   map mode '*' to '&'
%   modes in use: []
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #69, minPrec=0.98, maxC=1, maxL=7, minRel=POSSIBLE_ANSWER, maxNodes=10K

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr736(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd737(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 2 clause(s) at relevance level POSSIBLE_ANSWER:
% [AdviceProcessor]   mega_posAnd_notNegOr740(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd741(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 2 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #69 led to nothing being learned.

% RECONSIDERING Setting #70 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 1
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #70, minPrec=0.98, maxC=1, maxL=1

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr744(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd745(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice748(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice748(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice749(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice749(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr750(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd751(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice754(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice754(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice755(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice755(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #70 led to nothing being learned.

% RECONSIDERING Setting #71 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 3
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #71, minPrec=0.98, maxC=1, maxL=3

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr756(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd757(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice760(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice760(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice761(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice761(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr762(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd763(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice766(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice766(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice767(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice767(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #71 led to nothing being learned.

% RECONSIDERING Setting #72 (modified to perform a 'find anything' run).
%  The differences from the default settings are:
%   this setting was reconsidered (and relaxed) after it didn't suffice initially
%   maxNumberOfCycles  = 2
%   maxNumberOfClauses = 1
%   maxBodyLength      = 7
%   maxNodesToCreate   = 1,000
%   maxNodesToConsider = 10
%   minPosCoverage     = 0.0000
%   maxNegCoverage     = 10,000.0000
%   minPrecision       = 0.0000
%   mEstimatePos       = 0.0100
%   mEstimateNeg       = 0.0100
%   map mode '*' to '-'
%   modes in use: [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
%   all modes:    [Row/1, Length/2, Column/1, Height/2, Contains/3, Base/2, Ell/1, addList/2, multiplyList/2, abs/2, minus/2, plus/3, minus/3, mult/3, div/3, allNumbers/1, positiveNumber/1, negativeNumber/1, in0toDot001/1, in0toDot01/1, in0toDot1/1, in0to1/1, in0to10/1, in0to100/1, in0to1000/1, equalWithTolerance/3, greaterOrEqualDifference/3, smallerOrEqualDifference/3, isaEqualTolerance/1, lessThan/2, greaterThan/2, lessThanOrEqual/2, greaterThanOrEqual/2, inBetweenOO/3, inBetweenCO/3, inBetweenOC/3, inBetweenCC/3, memberOfList/2, firstInList/2, restOfList/2, positionInList/3, nthInList/3, lengthOfList/2]
% ILPparameterSettings.helpRun: annotationForSetting = ONION Layer #72, minPrec=0.98, maxC=1, maxL=7

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 0.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr768(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd769(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice772(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice772(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice773(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice773(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level RELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr774(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd775(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice778(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice778(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice779(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Height(A, E), 
% [AdviceProcessor]             Base(A, D), 
% [AdviceProcessor]             Contains(A, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice779(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Height(A, E), 
% [AdviceProcessor]                Base(A, D), 
% [AdviceProcessor]                Contains(A, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990098): Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]  score = 0.990

% Skipping over this 'waitHere': This search will never start for 'LearnOneClause': continueTheSearch = false, |open| = 1
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% The best node found: Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]

% On cycle #1, the best clause found is:
%      Ell(_).  [covers 1.0/1.0 pos, 0.0/0.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and NaN% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.01s):

% Created a total of 1 clauses and expanded 0 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 0) neg examples.

% % 
% % Clauses:

% Ell(A) :- true. // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 0.
     getWeightedCoverage: apply this clause (Ell(_) :- true)
  currently:  |falseNegatives| = 0 and |trueNegatives| = 0.
% RECONSIDERING Setting #72 led to nothing being learned.

% ------------------------------------------------


% Best Theory Chosen by the Onion:
    
%     Clauses:

    Ell(A) :- true. // Clause #1.



%              Actual
%             Pos   Neg Total
% Model Pos     1     0     1
%       Neg     0     0     0
%     Total     1     0

% False Pos mEst  = 0.0100
% False Neg mEst  = 0.0100

% Accuracy  = 0.9804
% Precision = 0.9901
% Recall    = 0.9901
% F(1)      = 0.9901

% ------------------------------------------------

% Took 1.763 seconds.
% Executed 222 proofs in 0.02 seconds (9630.69 proofs/sec).
% Performed 0 unifications while proving Horn clauses.
