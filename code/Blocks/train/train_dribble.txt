% Running on host: DESKTOP-A7D8Q9H

% Creating string handler #1.


% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.

% getInputArgWithDefaultValue: args=[C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_pos.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_neg.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_bk.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_facts.txt]
%  for N=0: args[N]=C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_pos.txt

% getInputArgWithDefaultValue: args=[C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_pos.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_neg.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_bk.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_facts.txt]
%  for N=1: args[N]=C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_neg.txt

% getInputArgWithDefaultValue: args=[C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_pos.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_neg.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_bk.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_facts.txt]
%  for N=2: args[N]=C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_bk.txt

% getInputArgWithDefaultValue: args=[C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_pos.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_neg.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_bk.txt, C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_facts.txt]
%  for N=3: args[N]=C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train_facts.txt

% Welcome to the WILL ILP/SRL systems.


% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.
% Reading background theory from dir: null
% Load '../blocks_bk.txt'.

% Switching to VarIndicator = uppercase.

***** Warning: At least one argument in a mode should be an input argument.  You provided signature = [const, const], types = [#Float1, #Float4] for 'sameAsNew'. *****


***** Warning: At least one argument in a mode should be an input argument.  You provided signature = [const, const, const], types = [#Float3, #Float2, #Float6] for 'equalWithToleranceNew'. *****


***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****

  loadThisFile: i=0 newName=precomputed.txt sents=[(sameAsNew(Float1, Float4) :- Length(Part, Float1), Base(Shape, Float4), equalWithSmallTolerance(Float1, Float4)), (equalWithToleranceNew(Float3, Float2, Float6) :- Height(Shape, Float3), H(Part, Float2), Float6 is Float3 - Float2)]

***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****

% LoadAllModes() called.  Currently loaded modes: []
TESTING BASIC MODES
% LoadAllLibraries() called.  Currently loaded libraries: [listsInLogic, differentInLogic, modes_arithmeticInLogic, inlines_comparisonInLogic, modes_listsInLogic, inlines_differentInLogic, modes_differentInLogic, arithmeticInLogic, inlines_listsInLogic, modes_comparisonInLogic, comparisonInLogic, inlines_arithmeticInLogic]

%  The Background Rules:

%  mode(Row(+Part))
%  mode(Length(+Part, #Float1))
%  mode(H(+Part, #Float2))
%  mode(Column(+Part))
%  mode(Contains(+Shape, -Part))
%  mode(Base(+Shape, #Float4))
%  mode(Height(+Shape, #Float3))
%  mode(SpRel(&Rel, #Float5, +Part, +Part))
%  mode(Ell(+Shape))
%  mode(sameAsNew(#Float1, #Float4))
%  mode(equalWithToleranceNew(#Float3, #Float2, #Float6))
%  isaInterestingSymbol(X, X) :- 
%     isaInterestingSymbol(X)
%  isaInterestingNumber(X, Y) :- 
%     isaInterestingNumber(Y),
%     equalWithSmallTolerance(X, Y)
%  isaDifferentInterestingSymbol(X, Y) :- 
%     isaInterestingSymbol(X),
%     isaInterestingSymbol(Y),
%     different(X, Y)
%  isaDifferentInterestingNumber(X, Y) :- 
%     isaInterestingNumber(X),
%     isaInterestingNumber(Y),
%     different(X, Y)
%  positiveNumber(X) :- 
%     number(X),
%     X > 0
%  negativeNumber(X) :- 
%     number(X),
%     X < 0
%  in0to1(X) :- 
%     number(X),
%     X >= 0,
%     X <= 1
%  in0to10(X) :- 
%     number(X),
%     X >= 0,
%     X <= 10
%  in0to100(X) :- 
%     number(X),
%     X >= 0,
%     X <= 100
%  in0to1000(X) :- 
%     number(X),
%     X >= 0,
%     X <= 1000
%  in0toDot001(X) :- 
%     number(X),
%     X >= 0,
%     X <= 0.001
%  in0toDot01(X) :- 
%     number(X),
%     X >= 0,
%     X <= 0.01
%  in0toDot1(X) :- 
%     number(X),
%     X >= 0,
%     X <= 0.1
%  greaterOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Temp is abs(X - Y),
%     Temp >= Z
%  greaterOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is abs(X - Y)
%  smallerOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Temp is abs(X - Y),
%     Temp =< Z
%  smallerOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is abs(X - Y)
%  sameAs(X, X) :- 
%     !
%  sameAs(X, Y) :- 
%     number(X),
%     number(Y),
%     equalWithSmallTolerance(X, Y),
%     !
%  sameAs([], []) :- 
%     !
%  sameAs([X1| Y1], [X2| Y2]) :- 
%     sameAs(X1, X2),
%     sameAs(Y1, Y2),
%     !
%  different(X, Y) :- 
%     \+(sameAs(X, Y))
%  equalWithSmallTolerance(X, X) :- 
%     !
%  equalWithSmallTolerance(X, Y) :- 
%     number(X),
%     number(Y),
%     !,
%     Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18),
%     Scaled < 1.0E-6
%  safeLog(0, Base, 1) :- 
%     !
%  safeLog(X, Base, Result) :- 
%     number(X),
%     number(Base),
%     Result is log(X, Base)
%  equalWithTolerance(X, Y, Tolerance) :- 
%     number(X),
%     number(Y),
%     isaEqualTolerance(Tolerance),
%     Diff is abs(X - Y),
%     Diff <= Tolerance
%  isaEqualTolerance(X) :- 
%     number(X),
%     X >= 0,
%     !
%  differentWithTolerance(X, Y, Tolerance) :- 
%     number(X),
%     number(Y),
%     isaEqualTolerance(Tolerance),
%     Diff is abs(X - Y),
%     Diff > Tolerance
%  lessThan(X, Y) :- 
%     number(X),
%     number(Y),
%     X < Y
%  greaterThan(X, Y) :- 
%     number(X),
%     number(Y),
%     X > Y
%  lessThanOrEqual(X, Y) :- 
%     number(X),
%     number(Y),
%     X <= Y
%  greaterThanOrEqual(X, Y) :- 
%     number(X),
%     number(Y),
%     X >= Y
%  inBetweenCC(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower <= Middle,
%     Middle <= Upper
%  inBetweenOC(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower < Middle,
%     Middle <= Upper
%  inBetweenCO(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower <= Middle,
%     Middle < Upper
%  inBetweenOO(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower < Middle,
%     Middle < Upper
%  addList(List, Result) :- 
%     allNumbers(List),
%     addListOfNumbers(List, Result)
%  multiplyList(List, Result) :- 
%     allNumbers(List),
%     multiplyListOfNumbers(List, Result)
%  allNumbers([X| Y]) :- 
%     number(X),
%     allNumbers(Y)
%  abs(X, Y) :- 
%     number(X),
%     var(Y),
%     Y is abs(X)
%  abs(X, Y) :- 
%     number(X),
%     number(Y),
%     Y is abs(X)
%  plus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X + Y
%  plus(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is Z - X
%  plus(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z - Y
%  minus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X - Y
%  minus(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is X - Z
%  minus(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z + Y
%  minus(X, Y) :- 
%     number(X),
%     var(Y),
%     !,
%     Y is -X
%  minus(X, Y) :- 
%     number(Y),
%     var(X),
%     !,
%     X is -Y
%  mult(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X * Y
%  mult(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is Z / X
%  mult(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z / Y
%  div(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X / Y
%  div(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is X / Z
%  div(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z * Y
%  exp(0, _, 0) :- 
%     !
%  exp(_, 0, 1) :- 
%     !
%  exp(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X ** Y
%  exp(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is log(Z) / log(X)
%  exp(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z ** (1 / Y)
%  log(X, _, _) :- 
%     number(X),
%     X <= 0,
%     !,
%     false()
%  log(1, _, 0) :- 
%     !
%  log(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is log(X, Y)
%  log(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Y ** Z
%  log(X, Y, Z) :- 
%     number(Z),
%     number(Z),
%     var(Y),
%     !,
%     Y is X ** (1 / Z)
%  log(X, Z) :- 
%     number(X),
%     var(Z),
%     !,
%     Z is log(X)
%  log(X, Z) :- 
%     number(Z),
%     var(X),
%     !,
%     X is exp(1) ** Z
%  max(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     !,
%     Z is max(X, Y)
%  min(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     !,
%     Z is min(X, Y)
%  plus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X + Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  minus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X - Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  mult(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X * Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  div(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is Z * Y,
%     equalWithSmallTolerance(X, Ztemp)
%  exp(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X ** Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  log(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is log(X, Y),
%     equalWithSmallTolerance(Z, Ztemp)
%  minus(X, Y) :- 
%     number(X),
%     number(Y),
%     !,
%     Ytemp is -X,
%     equalWithSmallTolerance(Z, Ztemp)
%  log(X, Z) :- 
%     number(X),
%     number(Y),
%     !,
%     Ztemp is log(X),
%     equalWithSmallTolerance(Z, Ztemp)
%  mode(addList(+willList, #willNumber))
%  mode(multiplyList(+willList, #willNumber))
%  mode(abs(+willNumber, &willNumber))
%  mode(minus(+willNumber, &willNumber))
%  mode(plus(+willNumber, +willNumber, &willNumber))
%  mode(minus(+willNumber, +willNumber, &willNumber))
%  mode(mult(+willNumber, +willNumber, &willNumber))
%  mode(div(+willNumber, +willNumber, &willNumber))
%  mode(allNumbers(+willList))
%  mode(positiveNumber(+willNumber))
%  mode(negativeNumber(+willNumber))
%  mode(in0toDot001(+willNumber))
%  mode(in0toDot01(+willNumber))
%  mode(in0toDot1(+willNumber))
%  mode(in0to1(+willNumber))
%  mode(in0to10(+willNumber))
%  mode(in0to100(+willNumber))
%  mode(in0to1000(+willNumber))
%  mode(equalWithTolerance(+willNumber, +willNumber, &willNumber))
%  mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber))
%  mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber))
%  mode(isaEqualTolerance(+willNumber))
%  mode(lessThan(+willNumber, +willNumber))
%  mode(greaterThan(+willNumber, +willNumber))
%  mode(lessThanOrEqual(+willNumber, +willNumber))
%  mode(greaterThanOrEqual(+willNumber, +willNumber))
%  mode(inBetweenOO(+willNumber, +willNumber, +willNumber))
%  mode(inBetweenCO(+willNumber, +willNumber, +willNumber))
%  mode(inBetweenOC(+willNumber, +willNumber, +willNumber))
%  mode(inBetweenCC(+willNumber, +willNumber, +willNumber))
%  member(X, Y) :- 
%     ground(X),
%     ground(Y),
%     !,
%     contains(X, Y)
%  member(X, [X| _])
%  member(X, [_| Y]) :- 
%     member(X, Y)
%  contains(X, [X| _]) :- 
%     !
%  contains(X, [_| Y]) :- 
%     contains(X, Y)
%  memberOfList(X, List) :- 
%     list(List),
%     member(X, List)
%  positionInList(X, [X| _], 0)
%  positionInList(X, List, N) :- 
%     list(List),
%     N is position(X, List)
%  firstInList(First, List) :- 
%     list(List),
%     First is first(List)
%  restOfList(Rest, List) :- 
%     list(List),
%     Rest is rest(List)
%  nthInList(N, List, Result) :- 
%     number(N),
%     list(List),
%     Result is nth(N, List)
%  lengthOfList(List, N) :- 
%     list(List),
%     N is length(List)
%  reverseList(List, A) :- 
%     list(List),
%     A is reverse(List)
%  reverseList(A, List) :- 
%     list(List),
%     A is reverse(List)
%  pushIntoList(A, List, C) :- 
%     list(List),
%     C is push(A, List)
%  removeFromList(A, List, C) :- 
%     list(List),
%     C is remove(A, List)
%  appendLists(List1, List2, Result) :- 
%     list(List1),
%     list(List2),
%     Result is append(List1, List2)
%  union([], B, B)
%  union([A| B], C, [A| ResultOnB]) :- 
%     \+(member(A, C)),
%     !,
%     union(B, C, ResultOnB)
%  union([A| B], C, ResultOnB) :- 
%     union(B, C, ResultOnB)
%  intersection([], _, [])
%  intersection([A| B], C, [A| ResultOnB]) :- 
%     member(A, C),
%     !,
%     intersection(B, C, ResultOnB)
%  intersection([A| B], C, ResultOnB) :- 
%     intersection(B, C, ResultOnB)
%  alwaysTrue(Index, List, Expression) :- 
%     memberOfList(Index, List),
%     \+(call(Expression)),
%     !,
%     fail
%  alwaysTrue(_, _, _)
%  sometimesTrue(Index, List, Expression) :- 
%     L is length(List),
%     memberOfList(Index, List),
%     call(Expression),
%     true
%  neverTrue(Index, List, Expression) :- 
%     member(Index, List),
%     call(Expression),
%     !,
%     fail
%  neverTrue(_, _, _) :- 
%     true
%  evaluateAll(Index, List, Expression) :- 
%     memberOfList(Index, List),
%     call(Expression),
%     fail
%  evaluateAll(_, _, _)
%  mode(memberOfList(+willAnything, +willList))
%  mode(firstInList(+willList, &willAnything))
%  mode(restOfList(+willList, &willList))
%  mode(positionInList(+willAnything, +willList, &willNumber))
%  mode(nthInList(+willNumber, +willList, &willAnything))
%  mode(lengthOfList(+willList, &willNumber))

%  Read the facts.
%  Have read 20 facts.
% Have read 1 examples from 'C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train' [C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train*].
% Have read 2 examples from 'C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train' [C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train/train*].

%  LearnOneClause initialized.

***** Warning: % Should not set minPosCoverage (2.0) to more than the total weight on the positive examples (1.0).  Will use the maximum possible value. *****

% Reading background theory from dir: C:\Users\Nandini\git\ConceptLearningOnion1Shot\code\Blocks\train
% Have read the relevance files.


% NEW target:                 Ell(D)
%  targetPred:                Ell/1
%  targetArgTypes:            signature = [const], types = [+Shape]
%  targets:                   [Ell(D)]
%  targetPredicates:          [Ell/1]
%  targetArgSpecs:            [[D[+Shape]]]
%  variablesInTargets:        [[D]]

% Precompute #0's requests: 'precomputed.txt'
%   sameAsNew(Float1, Float4) :- Length(Part, Float1), Base(Shape, Float4), equalWithSmallTolerance(Float1, Float4)
%   equalWithToleranceNew(Float3, Float2, Float6) :- Height(Shape, Float3), H(Part, Float2), Float6 is Float3 - Float2
% Processing precompute file: precomputed.txt
Writing to file: C:\Users\Nandini\git\ConceptLearningOnion1Shot\precomputed.txt
% Loading: precomputed.txt
% Read an additional 4 facts from edu.wisc.cs.will.Utils.condor.CondorFileReader@1ed6993a.

% Started collecting constants

% Collecting the types of constants.

%   *** WARNING ***  Constant '8' is already marked as being of types = [Float1];
%          type = 'Float4' may be added if not already known.
%  PredicateName = 'Base', from 'Base(s, 8)',
%  which has types = [signature = [const, const], types = [+Shape, #Float4]]
%   Other warnings with this predicate and this new type are not reported in order to keep this printout small.  Use dontComplainAboutMultipleTypes to override.

%   *** WARNING ***  Constant '8' is already marked as being of types = [Float1, Float4];
%          type = 'Float3' may be added if not already known.
%  PredicateName = 'Height', from 'Height(s, 8)',
%  which has types = [signature = [const, const], types = [+Shape, #Float3]]
%   Other warnings with this predicate and this new type are not reported in order to keep this printout small.  Use dontComplainAboutMultipleTypes to override.

% Looking at the training examples to see if any types of new constants can be inferred.
% Time to collect constants: 0 seconds
% Time to collect examples: 0 seconds

% Read 1 pos examples and 2 neg examples.
% Time to init learnOneClause: 0 seconds

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 2.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
Strength:: STRONGLY_IRRELEVANT
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr0(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd1(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice4(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice4(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice5(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice5(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #1: Duplicate cost of 'single_piece_advice5/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #2: Duplicate cost of 'mega_notPosAnd_negAnd1/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #3: Duplicate cost of 'not_single_example_advice4/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #4: Duplicate cost of 'mega_posAnd_notNegOr0/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #5: Duplicate cost of 'single_example_advice4/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #6: Duplicate cost of 'not_single_piece_advice5/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr6(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd7(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice10(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice10(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice11(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice11(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #7: Duplicate cost of 'mega_posAnd_notNegOr6/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #8: Duplicate cost of 'single_piece_advice11/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #9: Duplicate cost of 'not_single_piece_advice11/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #10: Duplicate cost of 'mega_notPosAnd_negAnd7/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #11: Duplicate cost of 'single_example_advice10/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #12: Duplicate cost of 'not_single_example_advice10/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.


% LearnOneClause Parameters:
%   Targets (1):
%    Ell(+Shape)
%  Modes (52):
%    Row(+Part),
%    Length(+Part, #Float1),
%    H(+Part, #Float2),
%    Column(+Part),
%    Contains(+Shape, -Part),
%    Base(+Shape, #Float4),
%    Height(+Shape, #Float3),
%    SpRel(&Rel, #Float5, +Part, +Part),
%    sameAsNew(#Float1, #Float4),
%    equalWithToleranceNew(#Float3, #Float2, #Float6),
%    addList(+willList, #willNumber),
%    multiplyList(+willList, #willNumber),
%    abs(+willNumber, &willNumber),
%    minus(+willNumber, &willNumber),
%    minus(+willNumber, +willNumber, &willNumber),
%    plus(+willNumber, +willNumber, &willNumber),
%    mult(+willNumber, +willNumber, &willNumber),
%    div(+willNumber, +willNumber, &willNumber),
%    allNumbers(+willList),
%    positiveNumber(+willNumber),
%    negativeNumber(+willNumber),
%    in0toDot001(+willNumber),
%    in0toDot01(+willNumber),
%    in0toDot1(+willNumber),
%    in0to1(+willNumber),
%    in0to10(+willNumber),
%    in0to100(+willNumber),
%    in0to1000(+willNumber),
%    equalWithTolerance(+willNumber, +willNumber, &willNumber),
%    greaterOrEqualDifference(+willNumber, +willNumber, &willNumber),
%    smallerOrEqualDifference(+willNumber, +willNumber, &willNumber),
%    isaEqualTolerance(+willNumber),
%    lessThan(+willNumber, +willNumber),
%    greaterThan(+willNumber, +willNumber),
%    lessThanOrEqual(+willNumber, +willNumber),
%    greaterThanOrEqual(+willNumber, +willNumber),
%    inBetweenOO(+willNumber, +willNumber, +willNumber),
%    inBetweenCO(+willNumber, +willNumber, +willNumber),
%    inBetweenOC(+willNumber, +willNumber, +willNumber),
%    inBetweenCC(+willNumber, +willNumber, +willNumber),
%    memberOfList(+willAnything, +willList),
%    firstInList(+willList, &willAnything),
%    restOfList(+willList, &willList),
%    positionInList(+willAnything, +willList, &willNumber),
%    nthInList(+willNumber, +willList, &willAnything),
%    lengthOfList(+willList, &willNumber),
%    mega_posAnd_notNegOr6(+Shape),
%    single_piece_advice11(+Shape),
%    not_single_piece_advice11(+Shape),
%    mega_notPosAnd_negAnd7(+Shape),
%    single_example_advice10(+Shape),
%    not_single_example_advice10(+Shape)

% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.332225): Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]  score = 0.332

% Consider expanding [#1 of outerLoop #1_fold0, bodyLen=0] 'Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]' score=0.3322248136212625
%  At # nodes expanded = 1, |OPEN| = 0.  Pruned 0 variant children.  Sending 13 items to OPEN for evaluation and possible insertion.
% Have created 13 valid-on-seeds descendants and have picked up 3 bad extensions.
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990089): Ell(A) :- Base(A, 8).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr6(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (mega_notPosAnd_negAnd7(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_example_advice10(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (not_single_example_advice10(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_piece_advice11(Anon1161) :- Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)), (not_single_piece_advice11(Anon1161) :- \+(Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)))]

***** Warning: #1 Gleaner: when handling inliners in: 
   (Ell(A) :- mega_posAnd_notNegOr6(A))
 got multiple clauses:
   [(Ell(A) :- mega_posAnd_notNegOr6(A)), (mega_posAnd_notNegOr6(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- mega_posAnd_notNegOr6(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr6(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (mega_notPosAnd_negAnd7(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_example_advice10(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (not_single_example_advice10(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_piece_advice11(Anon1161) :- Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)), (not_single_piece_advice11(Anon1161) :- \+(Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)))]

***** Warning: #2 Gleaner: when handling inliners in: 
   (Ell(A) :- single_piece_advice11(A))
 got multiple clauses:
   [(Ell(A) :- single_piece_advice11(A)), (single_piece_advice11(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr6(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (mega_notPosAnd_negAnd7(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_example_advice10(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (not_single_example_advice10(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_piece_advice11(Anon1161) :- Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)), (not_single_piece_advice11(Anon1161) :- \+(Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)))]

% The best node found: Ell(A) :- mega_posAnd_notNegOr6(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]after retraction

% The best node found: Ell(A) :- mega_posAnd_notNegOr6(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
outerlooper nontree
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr6(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (mega_notPosAnd_negAnd7(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_example_advice10(Anon1177) :- Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179)), (not_single_example_advice10(Anon1177) :- \+(Column(Anon1179), Row(Anon1181), Length(Anon1181, Anon1183), Base(Anon1177, Anon1185), Height(Anon1177, Anon1187), H(Anon1179, Anon1189), Contains(Anon1177, Anon1181), Contains(Anon1177, Anon1179), SpRel(topleft, Anon1191, Anon1181, Anon1179))), (single_piece_advice11(Anon1161) :- Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)), (not_single_piece_advice11(Anon1161) :- \+(Column(Anon1163), Row(Anon1165), Length(Anon1165, Anon1167), Base(Anon1161, Anon1169), Height(Anon1161, Anon1171), H(Anon1163, Anon1173), Contains(Anon1161, Anon1165), Contains(Anon1161, Anon1163), SpRel(topleft, Anon1175, Anon1165, Anon1163)))]

% On cycle #1, the best clause found is:
%      Ell(A) :- mega_posAnd_notNegOr6(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and 0.0% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.08s):

% Created a total of 14 clauses and expanded 1 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 2) neg examples.

% % 
% % Clauses:

% Ell(A) :- mega_posAnd_notNegOr6(A). // Clause #1.


% % Supporting Clauses:

% mega_posAnd_notNegOr6(A) :- 
%      Column(B), 
%      Row(C), 
%      Length(C, D), 
%      Base(A, E), 
%      Height(A, F), 
%      H(B, G), 
%      Contains(A, C), 
%      Contains(A, B), 
%      SpRel(topleft, H, C, B). // Supporting Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr6(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr6(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 2.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
Strength:: STRONGLY_IRRELEVANT
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr12(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd13(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice16(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice16(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice17(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice17(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #13: Duplicate cost of 'single_piece_advice17/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #14: Duplicate cost of 'not_single_piece_advice17/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #15: Duplicate cost of 'mega_posAnd_notNegOr12/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #16: Duplicate cost of 'not_single_example_advice16/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #17: Duplicate cost of 'single_example_advice16/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #18: Duplicate cost of 'mega_notPosAnd_negAnd13/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr18(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd19(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice22(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice22(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice23(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice23(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #19: Duplicate cost of 'not_single_piece_advice23/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #20: Duplicate cost of 'mega_notPosAnd_negAnd19/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #21: Duplicate cost of 'single_example_advice22/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #22: Duplicate cost of 'single_piece_advice23/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #23: Duplicate cost of 'mega_posAnd_notNegOr18/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #24: Duplicate cost of 'not_single_example_advice22/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.332225): Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]  score = 0.332

% Consider expanding [#1 of outerLoop #1_fold0, bodyLen=0] 'Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]' score=0.3322248136212625
%  At # nodes expanded = 1, |OPEN| = 0.  Pruned 0 variant children.  Sending 13 items to OPEN for evaluation and possible insertion.
% Have created 13 valid-on-seeds descendants and have picked up 3 bad extensions.
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990089): Ell(A) :- Base(A, 8).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr18(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (mega_notPosAnd_negAnd19(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_example_advice22(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (not_single_example_advice22(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_piece_advice23(Anon2171) :- Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)), (not_single_piece_advice23(Anon2171) :- \+(Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)))]

***** Warning: #1 Gleaner: when handling inliners in: 
   (Ell(A) :- single_example_advice22(A))
 got multiple clauses:
   [(Ell(A) :- single_example_advice22(A)), (single_example_advice22(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- single_example_advice22(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr18(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (mega_notPosAnd_negAnd19(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_example_advice22(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (not_single_example_advice22(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_piece_advice23(Anon2171) :- Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)), (not_single_piece_advice23(Anon2171) :- \+(Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)))]

***** Warning: #2 Gleaner: when handling inliners in: 
   (Ell(A) :- single_piece_advice23(A))
 got multiple clauses:
   [(Ell(A) :- single_piece_advice23(A)), (single_piece_advice23(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr18(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (mega_notPosAnd_negAnd19(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_example_advice22(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (not_single_example_advice22(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_piece_advice23(Anon2171) :- Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)), (not_single_piece_advice23(Anon2171) :- \+(Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)))]
% Gleaner: New best node found (score = 0.990099): Ell(A) :- mega_posAnd_notNegOr18(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]

% The best node found: Ell(A) :- mega_posAnd_notNegOr18(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]after retraction

% The best node found: Ell(A) :- mega_posAnd_notNegOr18(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
outerlooper nontree
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr18(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (mega_notPosAnd_negAnd19(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_example_advice22(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)), (not_single_example_advice22(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))), (single_piece_advice23(Anon2171) :- Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)), (not_single_piece_advice23(Anon2171) :- \+(Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)))]

% On cycle #1, the best clause found is:
%      Ell(A) :- mega_posAnd_notNegOr18(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and 0.0% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.05s):

% Created a total of 14 clauses and expanded 1 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 2) neg examples.

% % 
% % Clauses:

% Ell(A) :- mega_posAnd_notNegOr18(A). // Clause #1.


% % Supporting Clauses:

% mega_posAnd_notNegOr18(A) :- 
%      Column(B), 
%      Row(C), 
%      Length(C, D), 
%      Base(A, E), 
%      Height(A, F), 
%      H(B, G), 
%      Contains(A, C), 
%      Contains(A, B), 
%      SpRel(topleft, H, C, B). // Supporting Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr18(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr18(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
%  [mode(Row(+Part))]
%  [mode(Length(+Part, #Float1))]
%  [mode(H(+Part, #Float2))]
%  [mode(Column(+Part))]
%  [mode(Contains(+Shape, -Part))]
%  [mode(Base(+Shape, #Float4))]
%  [mode(Height(+Shape, #Float3))]
%  [mode(SpRel(&Rel, #Float5, +Part, +Part))]
%  [mode(Ell(+Shape))]
%  [mode(sameAsNew(#Float1, #Float4))]
%  [mode(equalWithToleranceNew(#Float3, #Float2, #Float6))]
%  [(isaInterestingSymbol(X, X) :- isaInterestingSymbol(X))]
%  [(isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y))]
%  [(isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y))]
%  [(isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y))]
%  [(positiveNumber(X) :- number(X), X > 0)]
%  [(negativeNumber(X) :- number(X), X < 0)]
%  [(in0to1(X) :- number(X), X >= 0, X <= 1)]
%  [(in0to10(X) :- number(X), X >= 0, X <= 10)]
%  [(in0to100(X) :- number(X), X >= 0, X <= 100)]
%  [(in0to1000(X) :- number(X), X >= 0, X <= 1000)]
%  [(in0toDot001(X) :- number(X), X >= 0, X <= 0.001)]
%  [(in0toDot01(X) :- number(X), X >= 0, X <= 0.01)]
%  [(in0toDot1(X) :- number(X), X >= 0, X <= 0.1)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z)]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(sameAs(X, X) :- !)]
%  [(sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !)]
%  [(sameAs([], []) :- !)]
%  [(sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !)]
%  [(different(X, Y) :- \+(sameAs(X, Y)))]
%  [(equalWithSmallTolerance(X, X) :- !)]
%  [(equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6)]
%  [(safeLog(0, Base, 1) :- !)]
%  [(safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base))]
%  [(equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance)]
%  [(isaEqualTolerance(X) :- number(X), X >= 0, !)]
%  [(differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance)]
%  [(lessThan(X, Y) :- number(X), number(Y), X < Y)]
%  [(greaterThan(X, Y) :- number(X), number(Y), X > Y)]
%  [(lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y)]
%  [(greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y)]
%  [(inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper)]
%  [(inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper)]
%  [(inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper)]
%  [(inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper)]
%  [(addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result))]
%  [(multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result))]
%  [(allNumbers([X| Y]) :- number(X), allNumbers(Y))]
%  [(abs(X, Y) :- number(X), var(Y), Y is abs(X))]
%  [(abs(X, Y) :- number(X), number(Y), Y is abs(X))]
%  [(plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y)]
%  [(plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X)]
%  [(plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z)]
%  [(minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y)]
%  [(minus(X, Y) :- number(X), var(Y), !, Y is -X)]
%  [(minus(X, Y) :- number(Y), var(X), !, X is -Y)]
%  [(mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y)]
%  [(mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X)]
%  [(mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y)]
%  [(div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y)]
%  [(div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z)]
%  [(div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y)]
%  [(exp(0, _, 0) :- !)]
%  [(exp(_, 0, 1) :- !)]
%  [(exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y)]
%  [(exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X))]
%  [(exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y))]
%  [(log(X, _, _) :- number(X), X <= 0, !, false())]
%  [(log(1, _, 0) :- !)]
%  [(log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y))]
%  [(log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z)]
%  [(log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z))]
%  [(log(X, Z) :- number(X), var(Z), !, Z is log(X))]
%  [(log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z)]
%  [(max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y))]
%  [(min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y))]
%  [(plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp))]
%  [(exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp))]
%  [mode(addList(+willList, #willNumber))]
%  [mode(multiplyList(+willList, #willNumber))]
%  [mode(abs(+willNumber, &willNumber))]
%  [mode(minus(+willNumber, &willNumber))]
%  [mode(plus(+willNumber, +willNumber, &willNumber))]
%  [mode(minus(+willNumber, +willNumber, &willNumber))]
%  [mode(mult(+willNumber, +willNumber, &willNumber))]
%  [mode(div(+willNumber, +willNumber, &willNumber))]
%  [mode(allNumbers(+willList))]
%  [mode(positiveNumber(+willNumber))]
%  [mode(negativeNumber(+willNumber))]
%  [mode(in0toDot001(+willNumber))]
%  [mode(in0toDot01(+willNumber))]
%  [mode(in0toDot1(+willNumber))]
%  [mode(in0to1(+willNumber))]
%  [mode(in0to10(+willNumber))]
%  [mode(in0to100(+willNumber))]
%  [mode(in0to1000(+willNumber))]
%  [mode(equalWithTolerance(+willNumber, +willNumber, &willNumber))]
%  [mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(isaEqualTolerance(+willNumber))]
%  [mode(lessThan(+willNumber, +willNumber))]
%  [mode(greaterThan(+willNumber, +willNumber))]
%  [mode(lessThanOrEqual(+willNumber, +willNumber))]
%  [mode(greaterThanOrEqual(+willNumber, +willNumber))]
%  [mode(inBetweenOO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenOC(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCC(+willNumber, +willNumber, +willNumber))]
%  [(member(X, Y) :- ground(X), ground(Y), !, contains(X, Y))]
%  [member(X, [X| _])]
%  [(member(X, [_| Y]) :- member(X, Y))]
%  [(contains(X, [X| _]) :- !)]
%  [(contains(X, [_| Y]) :- contains(X, Y))]
%  [(memberOfList(X, List) :- list(List), member(X, List))]
%  [positionInList(X, [X| _], 0)]
%  [(positionInList(X, List, N) :- list(List), N is position(X, List))]
%  [(firstInList(First, List) :- list(List), First is first(List))]
%  [(restOfList(Rest, List) :- list(List), Rest is rest(List))]
%  [(nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List))]
%  [(lengthOfList(List, N) :- list(List), N is length(List))]
%  [(reverseList(List, A) :- list(List), A is reverse(List))]
%  [(reverseList(A, List) :- list(List), A is reverse(List))]
%  [(pushIntoList(A, List, C) :- list(List), C is push(A, List))]
%  [(removeFromList(A, List, C) :- list(List), C is remove(A, List))]
%  [(appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2))]
%  [union([], B, B)]
%  [(union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB))]
%  [(union([A| B], C, ResultOnB) :- union(B, C, ResultOnB))]
%  [intersection([], _, [])]
%  [(intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB))]
%  [(intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB))]
%  [(alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail)]
%  [alwaysTrue(_, _, _)]
%  [(sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true)]
%  [(neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail)]
%  [(neverTrue(_, _, _) :- true)]
%  [(evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail)]
%  [evaluateAll(_, _, _)]
%  [mode(memberOfList(+willAnything, +willList))]
%  [mode(firstInList(+willList, &willAnything))]
%  [mode(restOfList(+willList, &willList))]
%  [mode(positionInList(+willAnything, +willList, &willNumber))]
%  [mode(nthInList(+willNumber, +willList, &willAnything))]
%  [mode(lengthOfList(+willList, &willNumber))]
%  [(mega_posAnd_notNegOr18(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))]
%  [(mega_notPosAnd_negAnd19(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)))]
%  [(single_example_advice22(Anon2187) :- Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189))]
%  [(not_single_example_advice22(Anon2187) :- \+(Column(Anon2189), Row(Anon2191), Length(Anon2191, Anon2193), Base(Anon2187, Anon2195), Height(Anon2187, Anon2197), H(Anon2189, Anon2199), Contains(Anon2187, Anon2191), Contains(Anon2187, Anon2189), SpRel(topleft, Anon2201, Anon2191, Anon2189)))]
%  [(single_piece_advice23(Anon2171) :- Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173))]
%  [(not_single_piece_advice23(Anon2171) :- \+(Column(Anon2173), Row(Anon2175), Length(Anon2175, Anon2177), Base(Anon2171, Anon2179), Height(Anon2171, Anon2181), H(Anon2173, Anon2183), Contains(Anon2171, Anon2175), Contains(Anon2171, Anon2173), SpRel(topleft, Anon2185, Anon2175, Anon2173)))]

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 2.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
Strength:: STRONGLY_IRRELEVANT
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr24(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd25(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice28(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice28(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice29(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice29(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #25: Duplicate cost of 'mega_posAnd_notNegOr24/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #26: Duplicate cost of 'single_piece_advice29/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #27: Duplicate cost of 'not_single_piece_advice29/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #28: Duplicate cost of 'not_single_example_advice28/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #29: Duplicate cost of 'single_example_advice28/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #30: Duplicate cost of 'mega_notPosAnd_negAnd25/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr30(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd31(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice34(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice34(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice35(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice35(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #31: Duplicate cost of 'mega_notPosAnd_negAnd31/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #32: Duplicate cost of 'single_example_advice34/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #33: Duplicate cost of 'not_single_piece_advice35/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #34: Duplicate cost of 'mega_posAnd_notNegOr30/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #35: Duplicate cost of 'not_single_example_advice34/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #36: Duplicate cost of 'single_piece_advice35/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.332225): Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]  score = 0.332

% Consider expanding [#1 of outerLoop #1_fold0, bodyLen=0] 'Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]' score=0.3322248136212625
%  At # nodes expanded = 1, |OPEN| = 0.  Pruned 0 variant children.  Sending 13 items to OPEN for evaluation and possible insertion.
% Have created 13 valid-on-seeds descendants and have picked up 3 bad extensions.
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990089): Ell(A) :- Base(A, 8).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr30(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (mega_notPosAnd_negAnd31(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_example_advice34(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (not_single_example_advice34(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_piece_advice35(Anon3183) :- Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)), (not_single_piece_advice35(Anon3183) :- \+(Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)))]

***** Warning: #1 Gleaner: when handling inliners in: 
   (Ell(A) :- single_example_advice34(A))
 got multiple clauses:
   [(Ell(A) :- single_example_advice34(A)), (single_example_advice34(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- single_example_advice34(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr30(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (mega_notPosAnd_negAnd31(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_example_advice34(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (not_single_example_advice34(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_piece_advice35(Anon3183) :- Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)), (not_single_piece_advice35(Anon3183) :- \+(Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)))]

***** Warning: #2 Gleaner: when handling inliners in: 
   (Ell(A) :- mega_posAnd_notNegOr30(A))
 got multiple clauses:
   [(Ell(A) :- mega_posAnd_notNegOr30(A)), (mega_posAnd_notNegOr30(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- mega_posAnd_notNegOr30(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr30(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (mega_notPosAnd_negAnd31(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_example_advice34(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (not_single_example_advice34(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_piece_advice35(Anon3183) :- Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)), (not_single_piece_advice35(Anon3183) :- \+(Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)))]

% The best node found: Ell(A) :- mega_posAnd_notNegOr30(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]after retraction

% The best node found: Ell(A) :- mega_posAnd_notNegOr30(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
outerlooper nontree
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr30(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (mega_notPosAnd_negAnd31(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_example_advice34(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)), (not_single_example_advice34(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))), (single_piece_advice35(Anon3183) :- Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)), (not_single_piece_advice35(Anon3183) :- \+(Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)))]

% On cycle #1, the best clause found is:
%      Ell(A) :- mega_posAnd_notNegOr30(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and 0.0% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.03s):

% Created a total of 14 clauses and expanded 1 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 2) neg examples.

% % 
% % Clauses:

% Ell(A) :- mega_posAnd_notNegOr30(A). // Clause #1.


% % Supporting Clauses:

% mega_posAnd_notNegOr30(A) :- 
%      Column(B), 
%      Row(C), 
%      Length(C, D), 
%      Base(A, E), 
%      Height(A, F), 
%      H(B, G), 
%      Contains(A, C), 
%      Contains(A, B), 
%      SpRel(topleft, H, C, B). // Supporting Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr30(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr30(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
%  [mode(Row(+Part))]
%  [mode(Length(+Part, #Float1))]
%  [mode(H(+Part, #Float2))]
%  [mode(Column(+Part))]
%  [mode(Contains(+Shape, -Part))]
%  [mode(Base(+Shape, #Float4))]
%  [mode(Height(+Shape, #Float3))]
%  [mode(SpRel(&Rel, #Float5, +Part, +Part))]
%  [mode(Ell(+Shape))]
%  [mode(sameAsNew(#Float1, #Float4))]
%  [mode(equalWithToleranceNew(#Float3, #Float2, #Float6))]
%  [(isaInterestingSymbol(X, X) :- isaInterestingSymbol(X))]
%  [(isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y))]
%  [(isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y))]
%  [(isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y))]
%  [(positiveNumber(X) :- number(X), X > 0)]
%  [(negativeNumber(X) :- number(X), X < 0)]
%  [(in0to1(X) :- number(X), X >= 0, X <= 1)]
%  [(in0to10(X) :- number(X), X >= 0, X <= 10)]
%  [(in0to100(X) :- number(X), X >= 0, X <= 100)]
%  [(in0to1000(X) :- number(X), X >= 0, X <= 1000)]
%  [(in0toDot001(X) :- number(X), X >= 0, X <= 0.001)]
%  [(in0toDot01(X) :- number(X), X >= 0, X <= 0.01)]
%  [(in0toDot1(X) :- number(X), X >= 0, X <= 0.1)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z)]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(sameAs(X, X) :- !)]
%  [(sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !)]
%  [(sameAs([], []) :- !)]
%  [(sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !)]
%  [(different(X, Y) :- \+(sameAs(X, Y)))]
%  [(equalWithSmallTolerance(X, X) :- !)]
%  [(equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6)]
%  [(safeLog(0, Base, 1) :- !)]
%  [(safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base))]
%  [(equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance)]
%  [(isaEqualTolerance(X) :- number(X), X >= 0, !)]
%  [(differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance)]
%  [(lessThan(X, Y) :- number(X), number(Y), X < Y)]
%  [(greaterThan(X, Y) :- number(X), number(Y), X > Y)]
%  [(lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y)]
%  [(greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y)]
%  [(inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper)]
%  [(inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper)]
%  [(inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper)]
%  [(inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper)]
%  [(addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result))]
%  [(multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result))]
%  [(allNumbers([X| Y]) :- number(X), allNumbers(Y))]
%  [(abs(X, Y) :- number(X), var(Y), Y is abs(X))]
%  [(abs(X, Y) :- number(X), number(Y), Y is abs(X))]
%  [(plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y)]
%  [(plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X)]
%  [(plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z)]
%  [(minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y)]
%  [(minus(X, Y) :- number(X), var(Y), !, Y is -X)]
%  [(minus(X, Y) :- number(Y), var(X), !, X is -Y)]
%  [(mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y)]
%  [(mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X)]
%  [(mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y)]
%  [(div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y)]
%  [(div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z)]
%  [(div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y)]
%  [(exp(0, _, 0) :- !)]
%  [(exp(_, 0, 1) :- !)]
%  [(exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y)]
%  [(exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X))]
%  [(exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y))]
%  [(log(X, _, _) :- number(X), X <= 0, !, false())]
%  [(log(1, _, 0) :- !)]
%  [(log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y))]
%  [(log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z)]
%  [(log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z))]
%  [(log(X, Z) :- number(X), var(Z), !, Z is log(X))]
%  [(log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z)]
%  [(max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y))]
%  [(min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y))]
%  [(plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp))]
%  [(exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp))]
%  [mode(addList(+willList, #willNumber))]
%  [mode(multiplyList(+willList, #willNumber))]
%  [mode(abs(+willNumber, &willNumber))]
%  [mode(minus(+willNumber, &willNumber))]
%  [mode(plus(+willNumber, +willNumber, &willNumber))]
%  [mode(minus(+willNumber, +willNumber, &willNumber))]
%  [mode(mult(+willNumber, +willNumber, &willNumber))]
%  [mode(div(+willNumber, +willNumber, &willNumber))]
%  [mode(allNumbers(+willList))]
%  [mode(positiveNumber(+willNumber))]
%  [mode(negativeNumber(+willNumber))]
%  [mode(in0toDot001(+willNumber))]
%  [mode(in0toDot01(+willNumber))]
%  [mode(in0toDot1(+willNumber))]
%  [mode(in0to1(+willNumber))]
%  [mode(in0to10(+willNumber))]
%  [mode(in0to100(+willNumber))]
%  [mode(in0to1000(+willNumber))]
%  [mode(equalWithTolerance(+willNumber, +willNumber, &willNumber))]
%  [mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(isaEqualTolerance(+willNumber))]
%  [mode(lessThan(+willNumber, +willNumber))]
%  [mode(greaterThan(+willNumber, +willNumber))]
%  [mode(lessThanOrEqual(+willNumber, +willNumber))]
%  [mode(greaterThanOrEqual(+willNumber, +willNumber))]
%  [mode(inBetweenOO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenOC(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCC(+willNumber, +willNumber, +willNumber))]
%  [(member(X, Y) :- ground(X), ground(Y), !, contains(X, Y))]
%  [member(X, [X| _])]
%  [(member(X, [_| Y]) :- member(X, Y))]
%  [(contains(X, [X| _]) :- !)]
%  [(contains(X, [_| Y]) :- contains(X, Y))]
%  [(memberOfList(X, List) :- list(List), member(X, List))]
%  [positionInList(X, [X| _], 0)]
%  [(positionInList(X, List, N) :- list(List), N is position(X, List))]
%  [(firstInList(First, List) :- list(List), First is first(List))]
%  [(restOfList(Rest, List) :- list(List), Rest is rest(List))]
%  [(nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List))]
%  [(lengthOfList(List, N) :- list(List), N is length(List))]
%  [(reverseList(List, A) :- list(List), A is reverse(List))]
%  [(reverseList(A, List) :- list(List), A is reverse(List))]
%  [(pushIntoList(A, List, C) :- list(List), C is push(A, List))]
%  [(removeFromList(A, List, C) :- list(List), C is remove(A, List))]
%  [(appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2))]
%  [union([], B, B)]
%  [(union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB))]
%  [(union([A| B], C, ResultOnB) :- union(B, C, ResultOnB))]
%  [intersection([], _, [])]
%  [(intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB))]
%  [(intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB))]
%  [(alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail)]
%  [alwaysTrue(_, _, _)]
%  [(sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true)]
%  [(neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail)]
%  [(neverTrue(_, _, _) :- true)]
%  [(evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail)]
%  [evaluateAll(_, _, _)]
%  [mode(memberOfList(+willAnything, +willList))]
%  [mode(firstInList(+willList, &willAnything))]
%  [mode(restOfList(+willList, &willList))]
%  [mode(positionInList(+willAnything, +willList, &willNumber))]
%  [mode(nthInList(+willNumber, +willList, &willAnything))]
%  [mode(lengthOfList(+willList, &willNumber))]
%  [(mega_posAnd_notNegOr30(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))]
%  [(mega_notPosAnd_negAnd31(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)))]
%  [(single_example_advice34(Anon3199) :- Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201))]
%  [(not_single_example_advice34(Anon3199) :- \+(Column(Anon3201), Row(Anon3203), Length(Anon3203, Anon3205), Base(Anon3199, Anon3207), Height(Anon3199, Anon3209), H(Anon3201, Anon3211), Contains(Anon3199, Anon3203), Contains(Anon3199, Anon3201), SpRel(topleft, Anon3213, Anon3203, Anon3201)))]
%  [(single_piece_advice35(Anon3183) :- Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185))]
%  [(not_single_piece_advice35(Anon3183) :- \+(Column(Anon3185), Row(Anon3187), Length(Anon3187, Anon3189), Base(Anon3183, Anon3191), Height(Anon3183, Anon3193), H(Anon3185, Anon3195), Contains(Anon3183, Anon3187), Contains(Anon3183, Anon3185), SpRel(topleft, Anon3197, Anon3187, Anon3185)))]

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 2.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
Strength:: STRONGLY_IRRELEVANT
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr36(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd37(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice40(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice40(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice41(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice41(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #37: Duplicate cost of 'mega_posAnd_notNegOr36/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #38: Duplicate cost of 'not_single_example_advice40/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #39: Duplicate cost of 'single_example_advice40/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #40: Duplicate cost of 'single_piece_advice41/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #41: Duplicate cost of 'not_single_piece_advice41/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #42: Duplicate cost of 'mega_notPosAnd_negAnd37/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr42(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd43(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice46(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice46(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice47(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice47(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #43: Duplicate cost of 'mega_notPosAnd_negAnd43/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #44: Duplicate cost of 'single_example_advice46/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #45: Duplicate cost of 'mega_posAnd_notNegOr42/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #46: Duplicate cost of 'not_single_piece_advice47/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #47: Duplicate cost of 'not_single_example_advice46/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #48: Duplicate cost of 'single_piece_advice47/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.332225): Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]  score = 0.332

% Consider expanding [#1 of outerLoop #1_fold0, bodyLen=0] 'Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]' score=0.3322248136212625
%  At # nodes expanded = 1, |OPEN| = 0.  Pruned 0 variant children.  Sending 13 items to OPEN for evaluation and possible insertion.
% Have created 13 valid-on-seeds descendants and have picked up 3 bad extensions.
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990089): Ell(A) :- Base(A, 8).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr42(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (mega_notPosAnd_negAnd43(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_example_advice46(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (not_single_example_advice46(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_piece_advice47(Anon4195) :- Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)), (not_single_piece_advice47(Anon4195) :- \+(Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)))]

***** Warning: #1 Gleaner: when handling inliners in: 
   (Ell(A) :- single_example_advice46(A))
 got multiple clauses:
   [(Ell(A) :- single_example_advice46(A)), (single_example_advice46(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- single_example_advice46(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr42(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (mega_notPosAnd_negAnd43(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_example_advice46(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (not_single_example_advice46(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_piece_advice47(Anon4195) :- Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)), (not_single_piece_advice47(Anon4195) :- \+(Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)))]

***** Warning: #2 Gleaner: when handling inliners in: 
   (Ell(A) :- mega_posAnd_notNegOr42(A))
 got multiple clauses:
   [(Ell(A) :- mega_posAnd_notNegOr42(A)), (mega_posAnd_notNegOr42(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- mega_posAnd_notNegOr42(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr42(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (mega_notPosAnd_negAnd43(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_example_advice46(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (not_single_example_advice46(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_piece_advice47(Anon4195) :- Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)), (not_single_piece_advice47(Anon4195) :- \+(Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)))]

% The best node found: Ell(A) :- mega_posAnd_notNegOr42(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]after retraction

% The best node found: Ell(A) :- mega_posAnd_notNegOr42(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
outerlooper nontree
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr42(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (mega_notPosAnd_negAnd43(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_example_advice46(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)), (not_single_example_advice46(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))), (single_piece_advice47(Anon4195) :- Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)), (not_single_piece_advice47(Anon4195) :- \+(Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)))]

% On cycle #1, the best clause found is:
%      Ell(A) :- mega_posAnd_notNegOr42(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and 0.0% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.06s):

% Created a total of 14 clauses and expanded 1 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 2) neg examples.

% % 
% % Clauses:

% Ell(A) :- mega_posAnd_notNegOr42(A). // Clause #1.


% % Supporting Clauses:

% mega_posAnd_notNegOr42(A) :- 
%      Column(B), 
%      Row(C), 
%      Length(C, D), 
%      Base(A, E), 
%      Height(A, F), 
%      H(B, G), 
%      Contains(A, C), 
%      Contains(A, B), 
%      SpRel(topleft, H, C, B). // Supporting Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr42(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr42(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
%  [mode(Row(+Part))]
%  [mode(Length(+Part, #Float1))]
%  [mode(H(+Part, #Float2))]
%  [mode(Column(+Part))]
%  [mode(Contains(+Shape, -Part))]
%  [mode(Base(+Shape, #Float4))]
%  [mode(Height(+Shape, #Float3))]
%  [mode(SpRel(&Rel, #Float5, +Part, +Part))]
%  [mode(Ell(+Shape))]
%  [mode(sameAsNew(#Float1, #Float4))]
%  [mode(equalWithToleranceNew(#Float3, #Float2, #Float6))]
%  [(isaInterestingSymbol(X, X) :- isaInterestingSymbol(X))]
%  [(isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y))]
%  [(isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y))]
%  [(isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y))]
%  [(positiveNumber(X) :- number(X), X > 0)]
%  [(negativeNumber(X) :- number(X), X < 0)]
%  [(in0to1(X) :- number(X), X >= 0, X <= 1)]
%  [(in0to10(X) :- number(X), X >= 0, X <= 10)]
%  [(in0to100(X) :- number(X), X >= 0, X <= 100)]
%  [(in0to1000(X) :- number(X), X >= 0, X <= 1000)]
%  [(in0toDot001(X) :- number(X), X >= 0, X <= 0.001)]
%  [(in0toDot01(X) :- number(X), X >= 0, X <= 0.01)]
%  [(in0toDot1(X) :- number(X), X >= 0, X <= 0.1)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z)]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(sameAs(X, X) :- !)]
%  [(sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !)]
%  [(sameAs([], []) :- !)]
%  [(sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !)]
%  [(different(X, Y) :- \+(sameAs(X, Y)))]
%  [(equalWithSmallTolerance(X, X) :- !)]
%  [(equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6)]
%  [(safeLog(0, Base, 1) :- !)]
%  [(safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base))]
%  [(equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance)]
%  [(isaEqualTolerance(X) :- number(X), X >= 0, !)]
%  [(differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance)]
%  [(lessThan(X, Y) :- number(X), number(Y), X < Y)]
%  [(greaterThan(X, Y) :- number(X), number(Y), X > Y)]
%  [(lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y)]
%  [(greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y)]
%  [(inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper)]
%  [(inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper)]
%  [(inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper)]
%  [(inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper)]
%  [(addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result))]
%  [(multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result))]
%  [(allNumbers([X| Y]) :- number(X), allNumbers(Y))]
%  [(abs(X, Y) :- number(X), var(Y), Y is abs(X))]
%  [(abs(X, Y) :- number(X), number(Y), Y is abs(X))]
%  [(plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y)]
%  [(plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X)]
%  [(plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z)]
%  [(minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y)]
%  [(minus(X, Y) :- number(X), var(Y), !, Y is -X)]
%  [(minus(X, Y) :- number(Y), var(X), !, X is -Y)]
%  [(mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y)]
%  [(mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X)]
%  [(mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y)]
%  [(div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y)]
%  [(div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z)]
%  [(div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y)]
%  [(exp(0, _, 0) :- !)]
%  [(exp(_, 0, 1) :- !)]
%  [(exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y)]
%  [(exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X))]
%  [(exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y))]
%  [(log(X, _, _) :- number(X), X <= 0, !, false())]
%  [(log(1, _, 0) :- !)]
%  [(log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y))]
%  [(log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z)]
%  [(log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z))]
%  [(log(X, Z) :- number(X), var(Z), !, Z is log(X))]
%  [(log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z)]
%  [(max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y))]
%  [(min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y))]
%  [(plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp))]
%  [(exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp))]
%  [mode(addList(+willList, #willNumber))]
%  [mode(multiplyList(+willList, #willNumber))]
%  [mode(abs(+willNumber, &willNumber))]
%  [mode(minus(+willNumber, &willNumber))]
%  [mode(plus(+willNumber, +willNumber, &willNumber))]
%  [mode(minus(+willNumber, +willNumber, &willNumber))]
%  [mode(mult(+willNumber, +willNumber, &willNumber))]
%  [mode(div(+willNumber, +willNumber, &willNumber))]
%  [mode(allNumbers(+willList))]
%  [mode(positiveNumber(+willNumber))]
%  [mode(negativeNumber(+willNumber))]
%  [mode(in0toDot001(+willNumber))]
%  [mode(in0toDot01(+willNumber))]
%  [mode(in0toDot1(+willNumber))]
%  [mode(in0to1(+willNumber))]
%  [mode(in0to10(+willNumber))]
%  [mode(in0to100(+willNumber))]
%  [mode(in0to1000(+willNumber))]
%  [mode(equalWithTolerance(+willNumber, +willNumber, &willNumber))]
%  [mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(isaEqualTolerance(+willNumber))]
%  [mode(lessThan(+willNumber, +willNumber))]
%  [mode(greaterThan(+willNumber, +willNumber))]
%  [mode(lessThanOrEqual(+willNumber, +willNumber))]
%  [mode(greaterThanOrEqual(+willNumber, +willNumber))]
%  [mode(inBetweenOO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenOC(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCC(+willNumber, +willNumber, +willNumber))]
%  [(member(X, Y) :- ground(X), ground(Y), !, contains(X, Y))]
%  [member(X, [X| _])]
%  [(member(X, [_| Y]) :- member(X, Y))]
%  [(contains(X, [X| _]) :- !)]
%  [(contains(X, [_| Y]) :- contains(X, Y))]
%  [(memberOfList(X, List) :- list(List), member(X, List))]
%  [positionInList(X, [X| _], 0)]
%  [(positionInList(X, List, N) :- list(List), N is position(X, List))]
%  [(firstInList(First, List) :- list(List), First is first(List))]
%  [(restOfList(Rest, List) :- list(List), Rest is rest(List))]
%  [(nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List))]
%  [(lengthOfList(List, N) :- list(List), N is length(List))]
%  [(reverseList(List, A) :- list(List), A is reverse(List))]
%  [(reverseList(A, List) :- list(List), A is reverse(List))]
%  [(pushIntoList(A, List, C) :- list(List), C is push(A, List))]
%  [(removeFromList(A, List, C) :- list(List), C is remove(A, List))]
%  [(appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2))]
%  [union([], B, B)]
%  [(union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB))]
%  [(union([A| B], C, ResultOnB) :- union(B, C, ResultOnB))]
%  [intersection([], _, [])]
%  [(intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB))]
%  [(intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB))]
%  [(alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail)]
%  [alwaysTrue(_, _, _)]
%  [(sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true)]
%  [(neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail)]
%  [(neverTrue(_, _, _) :- true)]
%  [(evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail)]
%  [evaluateAll(_, _, _)]
%  [mode(memberOfList(+willAnything, +willList))]
%  [mode(firstInList(+willList, &willAnything))]
%  [mode(restOfList(+willList, &willList))]
%  [mode(positionInList(+willAnything, +willList, &willNumber))]
%  [mode(nthInList(+willNumber, +willList, &willAnything))]
%  [mode(lengthOfList(+willList, &willNumber))]
%  [(mega_posAnd_notNegOr42(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))]
%  [(mega_notPosAnd_negAnd43(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)))]
%  [(single_example_advice46(Anon4211) :- Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213))]
%  [(not_single_example_advice46(Anon4211) :- \+(Column(Anon4213), Row(Anon4215), Length(Anon4215, Anon4217), Base(Anon4211, Anon4219), Height(Anon4211, Anon4221), H(Anon4213, Anon4223), Contains(Anon4211, Anon4215), Contains(Anon4211, Anon4213), SpRel(topleft, Anon4225, Anon4215, Anon4213)))]
%  [(single_piece_advice47(Anon4195) :- Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197))]
%  [(not_single_piece_advice47(Anon4195) :- \+(Column(Anon4197), Row(Anon4199), Length(Anon4199, Anon4201), Base(Anon4195, Anon4203), Height(Anon4195, Anon4205), H(Anon4197, Anon4207), Contains(Anon4195, Anon4199), Contains(Anon4195, Anon4197), SpRel(topleft, Anon4209, Anon4199, Anon4197)))]

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 2.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
Strength:: STRONGLY_IRRELEVANT
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr48(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd49(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice52(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice52(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice53(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice53(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #49: Duplicate cost of 'mega_posAnd_notNegOr48/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #50: Duplicate cost of 'single_piece_advice53/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #51: Duplicate cost of 'not_single_piece_advice53/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #52: Duplicate cost of 'mega_notPosAnd_negAnd49/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #53: Duplicate cost of 'not_single_example_advice52/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #54: Duplicate cost of 'single_example_advice52/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% Have selected pos example #0 as the next seed: Ell(s)
% [AdviceProcessor] retractRelevanceAdvice: there are 6 assertedRelevanceModes to retract.
% [AdviceProcessor]  Generated 6 clause(s) at relevance level STRONGLY_IRRELEVANT:
% [AdviceProcessor]   mega_posAnd_notNegOr54(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  POSSIBLE_ANSWER
% [AdviceProcessor]   mega_notPosAnd_negAnd55(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  POSSIBLE_ANSWER
% [AdviceProcessor]   single_example_advice58(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  VERY_STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_example_advice58(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  VERY_STRONGLY_RELEVANT_NEG
% [AdviceProcessor]   single_piece_advice59(A) :- 
% [AdviceProcessor]             Column(B), 
% [AdviceProcessor]             Row(C), 
% [AdviceProcessor]             Length(C, D), 
% [AdviceProcessor]             Base(A, E), 
% [AdviceProcessor]             Height(A, F), 
% [AdviceProcessor]             H(B, G), 
% [AdviceProcessor]             Contains(A, C), 
% [AdviceProcessor]             Contains(A, B), 
% [AdviceProcessor]             SpRel(topleft, H, C, B)  STRONGLY_RELEVANT
% [AdviceProcessor]   not_single_piece_advice59(A) :- 
% [AdviceProcessor]             \+(Column(B), 
% [AdviceProcessor]                Row(C), 
% [AdviceProcessor]                Length(C, D), 
% [AdviceProcessor]                Base(A, E), 
% [AdviceProcessor]                Height(A, F), 
% [AdviceProcessor]                H(B, G), 
% [AdviceProcessor]                Contains(A, C), 
% [AdviceProcessor]                Contains(A, B), 
% [AdviceProcessor]                SpRel(topleft, H, C, B)
% [AdviceProcessor]               )  STRONGLY_RELEVANT_NEG

% WARNING #55: Duplicate cost of 'single_example_advice58/1'.  Had previously said cost = 0.01001 and now saying cost = 0.01.
% Will use this latest setting.

% WARNING #56: Duplicate cost of 'mega_posAnd_notNegOr54/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.

% WARNING #57: Duplicate cost of 'not_single_piece_advice59/1'.  Had previously said cost = 0.15001 and now saying cost = 0.15.
% Will use this latest setting.

% WARNING #58: Duplicate cost of 'not_single_example_advice58/1'.  Had previously said cost = 0.015009999999999999 and now saying cost = 0.015.
% Will use this latest setting.

% WARNING #59: Duplicate cost of 'single_piece_advice59/1'.  Had previously said cost = 0.10001 and now saying cost = 0.1.
% Will use this latest setting.

% WARNING #60: Duplicate cost of 'mega_notPosAnd_negAnd55/1'.  Had previously said cost = 0.00101 and now saying cost = 0.001.
% Will use this latest setting.


% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.332225): Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]  score = 0.332

% Consider expanding [#1 of outerLoop #1_fold0, bodyLen=0] 'Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]' score=0.3322248136212625
%  At # nodes expanded = 1, |OPEN| = 0.  Pruned 0 variant children.  Sending 13 items to OPEN for evaluation and possible insertion.
% Have created 13 valid-on-seeds descendants and have picked up 3 bad extensions.
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990089): Ell(A) :- Base(A, 8).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr54(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (mega_notPosAnd_negAnd55(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_example_advice58(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (not_single_example_advice58(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_piece_advice59(Anon5207) :- Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)), (not_single_piece_advice59(Anon5207) :- \+(Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)))]

***** Warning: #1 Gleaner: when handling inliners in: 
   (Ell(A) :- single_example_advice58(A))
 got multiple clauses:
   [(Ell(A) :- single_example_advice58(A)), (single_example_advice58(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- single_example_advice58(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr54(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (mega_notPosAnd_negAnd55(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_example_advice58(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (not_single_example_advice58(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_piece_advice59(Anon5207) :- Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)), (not_single_piece_advice59(Anon5207) :- \+(Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)))]

***** Warning: #2 Gleaner: when handling inliners in: 
   (Ell(A) :- mega_posAnd_notNegOr54(A))
 got multiple clauses:
   [(Ell(A) :- mega_posAnd_notNegOr54(A)), (mega_posAnd_notNegOr54(A) :- Column(B), Row(C), Length(C, _), Base(A, _), Height(A, _), H(B, _), Contains(A, C), Contains(A, B), SpRel(topleft, _, C, B))] *****

% Gleaner: New best node found (score = 0.990099): Ell(A) :- mega_posAnd_notNegOr54(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr54(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (mega_notPosAnd_negAnd55(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_example_advice58(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (not_single_example_advice58(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_piece_advice59(Anon5207) :- Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)), (not_single_piece_advice59(Anon5207) :- \+(Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)))]

% The best node found: Ell(A) :- mega_posAnd_notNegOr54(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]after retraction

% The best node found: Ell(A) :- mega_posAnd_notNegOr54(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
outerlooper nontree
Is it here
[mode(Row(+Part)), mode(Length(+Part, #Float1)), mode(H(+Part, #Float2)), mode(Column(+Part)), mode(Contains(+Shape, -Part)), mode(Base(+Shape, #Float4)), mode(Height(+Shape, #Float3)), mode(SpRel(&Rel, #Float5, +Part, +Part)), mode(Ell(+Shape)), mode(sameAsNew(#Float1, #Float4)), mode(equalWithToleranceNew(#Float3, #Float2, #Float6)), (isaInterestingSymbol(X, X) :- isaInterestingSymbol(X)), (isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y)), (isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y)), (isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y)), (positiveNumber(X) :- number(X), X > 0), (negativeNumber(X) :- number(X), X < 0), (in0to1(X) :- number(X), X >= 0, X <= 1), (in0to10(X) :- number(X), X >= 0, X <= 10), (in0to100(X) :- number(X), X >= 0, X <= 100), (in0to1000(X) :- number(X), X >= 0, X <= 1000), (in0toDot001(X) :- number(X), X >= 0, X <= 0.001), (in0toDot01(X) :- number(X), X >= 0, X <= 0.01), (in0toDot1(X) :- number(X), X >= 0, X <= 0.1), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z), (greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z), (smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y)), (sameAs(X, X) :- !), (sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !), (sameAs([], []) :- !), (sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !), (different(X, Y) :- \+(sameAs(X, Y))), (equalWithSmallTolerance(X, X) :- !), (equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6), (safeLog(0, Base, 1) :- !), (safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base)), (equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance), (isaEqualTolerance(X) :- number(X), X >= 0, !), (differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance), (lessThan(X, Y) :- number(X), number(Y), X < Y), (greaterThan(X, Y) :- number(X), number(Y), X > Y), (lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y), (greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y), (inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper), (inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper), (inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper), (inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper), (addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result)), (multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result)), (allNumbers([X| Y]) :- number(X), allNumbers(Y)), (abs(X, Y) :- number(X), var(Y), Y is abs(X)), (abs(X, Y) :- number(X), number(Y), Y is abs(X)), (plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y), (plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X), (plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y), (minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y), (minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z), (minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y), (minus(X, Y) :- number(X), var(Y), !, Y is -X), (minus(X, Y) :- number(Y), var(X), !, X is -Y), (mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y), (mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X), (mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y), (div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y), (div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z), (div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y), (exp(0, _, 0) :- !), (exp(_, 0, 1) :- !), (exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y), (exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X)), (exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y)), (log(X, _, _) :- number(X), X <= 0, !, false()), (log(1, _, 0) :- !), (log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y)), (log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z), (log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z)), (log(X, Z) :- number(X), var(Z), !, Z is log(X)), (log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z), (max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y)), (min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y)), (plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp)), (mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp)), (div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp)), (exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp)), (log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp)), (minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp)), (log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp)), mode(addList(+willList, #willNumber)), mode(multiplyList(+willList, #willNumber)), mode(abs(+willNumber, &willNumber)), mode(minus(+willNumber, &willNumber)), mode(plus(+willNumber, +willNumber, &willNumber)), mode(minus(+willNumber, +willNumber, &willNumber)), mode(mult(+willNumber, +willNumber, &willNumber)), mode(div(+willNumber, +willNumber, &willNumber)), mode(allNumbers(+willList)), mode(positiveNumber(+willNumber)), mode(negativeNumber(+willNumber)), mode(in0toDot001(+willNumber)), mode(in0toDot01(+willNumber)), mode(in0toDot1(+willNumber)), mode(in0to1(+willNumber)), mode(in0to10(+willNumber)), mode(in0to100(+willNumber)), mode(in0to1000(+willNumber)), mode(equalWithTolerance(+willNumber, +willNumber, &willNumber)), mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber)), mode(isaEqualTolerance(+willNumber)), mode(lessThan(+willNumber, +willNumber)), mode(greaterThan(+willNumber, +willNumber)), mode(lessThanOrEqual(+willNumber, +willNumber)), mode(greaterThanOrEqual(+willNumber, +willNumber)), mode(inBetweenOO(+willNumber, +willNumber, +willNumber)), mode(inBetweenCO(+willNumber, +willNumber, +willNumber)), mode(inBetweenOC(+willNumber, +willNumber, +willNumber)), mode(inBetweenCC(+willNumber, +willNumber, +willNumber)), (member(X, Y) :- ground(X), ground(Y), !, contains(X, Y)), member(X, [X| _]), (member(X, [_| Y]) :- member(X, Y)), (contains(X, [X| _]) :- !), (contains(X, [_| Y]) :- contains(X, Y)), (memberOfList(X, List) :- list(List), member(X, List)), positionInList(X, [X| _], 0), (positionInList(X, List, N) :- list(List), N is position(X, List)), (firstInList(First, List) :- list(List), First is first(List)), (restOfList(Rest, List) :- list(List), Rest is rest(List)), (nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List)), (lengthOfList(List, N) :- list(List), N is length(List)), (reverseList(List, A) :- list(List), A is reverse(List)), (reverseList(A, List) :- list(List), A is reverse(List)), (pushIntoList(A, List, C) :- list(List), C is push(A, List)), (removeFromList(A, List, C) :- list(List), C is remove(A, List)), (appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2)), union([], B, B), (union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB)), (union([A| B], C, ResultOnB) :- union(B, C, ResultOnB)), intersection([], _, []), (intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB)), (intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB)), (alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail), alwaysTrue(_, _, _), (sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true), (neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail), (neverTrue(_, _, _) :- true), (evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail), evaluateAll(_, _, _), mode(memberOfList(+willAnything, +willList)), mode(firstInList(+willList, &willAnything)), mode(restOfList(+willList, &willList)), mode(positionInList(+willAnything, +willList, &willNumber)), mode(nthInList(+willNumber, +willList, &willAnything)), mode(lengthOfList(+willList, &willNumber)), (mega_posAnd_notNegOr54(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (mega_notPosAnd_negAnd55(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_example_advice58(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)), (not_single_example_advice58(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))), (single_piece_advice59(Anon5207) :- Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)), (not_single_piece_advice59(Anon5207) :- \+(Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)))]

% On cycle #1, the best clause found is:
%      Ell(A) :- mega_posAnd_notNegOr54(A).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and 0.0% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.03s):

% Created a total of 14 clauses and expanded 1 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 2) neg examples.

% % 
% % Clauses:

% Ell(A) :- mega_posAnd_notNegOr54(A). // Clause #1.


% % Supporting Clauses:

% mega_posAnd_notNegOr54(A) :- 
%      Column(B), 
%      Row(C), 
%      Length(C, D), 
%      Base(A, E), 
%      Height(A, F), 
%      H(B, G), 
%      Contains(A, C), 
%      Contains(A, B), 
%      SpRel(topleft, H, C, B). // Supporting Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr54(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- mega_posAnd_notNegOr54(A))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
%  [mode(Row(+Part))]
%  [mode(Length(+Part, #Float1))]
%  [mode(H(+Part, #Float2))]
%  [mode(Column(+Part))]
%  [mode(Contains(+Shape, -Part))]
%  [mode(Base(+Shape, #Float4))]
%  [mode(Height(+Shape, #Float3))]
%  [mode(SpRel(&Rel, #Float5, +Part, +Part))]
%  [mode(Ell(+Shape))]
%  [mode(sameAsNew(#Float1, #Float4))]
%  [mode(equalWithToleranceNew(#Float3, #Float2, #Float6))]
%  [(isaInterestingSymbol(X, X) :- isaInterestingSymbol(X))]
%  [(isaInterestingNumber(X, Y) :- isaInterestingNumber(Y), equalWithSmallTolerance(X, Y))]
%  [(isaDifferentInterestingSymbol(X, Y) :- isaInterestingSymbol(X), isaInterestingSymbol(Y), different(X, Y))]
%  [(isaDifferentInterestingNumber(X, Y) :- isaInterestingNumber(X), isaInterestingNumber(Y), different(X, Y))]
%  [(positiveNumber(X) :- number(X), X > 0)]
%  [(negativeNumber(X) :- number(X), X < 0)]
%  [(in0to1(X) :- number(X), X >= 0, X <= 1)]
%  [(in0to10(X) :- number(X), X >= 0, X <= 10)]
%  [(in0to100(X) :- number(X), X >= 0, X <= 100)]
%  [(in0to1000(X) :- number(X), X >= 0, X <= 1000)]
%  [(in0toDot001(X) :- number(X), X >= 0, X <= 0.001)]
%  [(in0toDot01(X) :- number(X), X >= 0, X <= 0.01)]
%  [(in0toDot1(X) :- number(X), X >= 0, X <= 0.1)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp >= Z)]
%  [(greaterOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), number(Z), !, Temp is abs(X - Y), Temp =< Z)]
%  [(smallerOrEqualDifference(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is abs(X - Y))]
%  [(sameAs(X, X) :- !)]
%  [(sameAs(X, Y) :- number(X), number(Y), equalWithSmallTolerance(X, Y), !)]
%  [(sameAs([], []) :- !)]
%  [(sameAs([X1| Y1], [X2| Y2]) :- sameAs(X1, X2), sameAs(Y1, Y2), !)]
%  [(different(X, Y) :- \+(sameAs(X, Y)))]
%  [(equalWithSmallTolerance(X, X) :- !)]
%  [(equalWithSmallTolerance(X, Y) :- number(X), number(Y), !, Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18), Scaled < 1.0E-6)]
%  [(safeLog(0, Base, 1) :- !)]
%  [(safeLog(X, Base, Result) :- number(X), number(Base), Result is log(X, Base))]
%  [(equalWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff <= Tolerance)]
%  [(isaEqualTolerance(X) :- number(X), X >= 0, !)]
%  [(differentWithTolerance(X, Y, Tolerance) :- number(X), number(Y), isaEqualTolerance(Tolerance), Diff is abs(X - Y), Diff > Tolerance)]
%  [(lessThan(X, Y) :- number(X), number(Y), X < Y)]
%  [(greaterThan(X, Y) :- number(X), number(Y), X > Y)]
%  [(lessThanOrEqual(X, Y) :- number(X), number(Y), X <= Y)]
%  [(greaterThanOrEqual(X, Y) :- number(X), number(Y), X >= Y)]
%  [(inBetweenCC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle <= Upper)]
%  [(inBetweenOC(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle <= Upper)]
%  [(inBetweenCO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower <= Middle, Middle < Upper)]
%  [(inBetweenOO(Lower, Middle, Upper) :- number(Lower), number(Middle), number(Upper), Lower < Middle, Middle < Upper)]
%  [(addList(List, Result) :- allNumbers(List), addListOfNumbers(List, Result))]
%  [(multiplyList(List, Result) :- allNumbers(List), multiplyListOfNumbers(List, Result))]
%  [(allNumbers([X| Y]) :- number(X), allNumbers(Y))]
%  [(abs(X, Y) :- number(X), var(Y), Y is abs(X))]
%  [(abs(X, Y) :- number(X), number(Y), Y is abs(X))]
%  [(plus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X + Y)]
%  [(plus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z - X)]
%  [(plus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X - Y)]
%  [(minus(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X - Z)]
%  [(minus(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z + Y)]
%  [(minus(X, Y) :- number(X), var(Y), !, Y is -X)]
%  [(minus(X, Y) :- number(Y), var(X), !, X is -Y)]
%  [(mult(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X * Y)]
%  [(mult(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is Z / X)]
%  [(mult(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z / Y)]
%  [(div(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X / Y)]
%  [(div(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is X / Z)]
%  [(div(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z * Y)]
%  [(exp(0, _, 0) :- !)]
%  [(exp(_, 0, 1) :- !)]
%  [(exp(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is X ** Y)]
%  [(exp(X, Y, Z) :- number(X), number(Z), var(Y), !, Y is log(Z) / log(X))]
%  [(exp(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Z ** (1 / Y))]
%  [(log(X, _, _) :- number(X), X <= 0, !, false())]
%  [(log(1, _, 0) :- !)]
%  [(log(X, Y, Z) :- number(X), number(Y), var(Z), !, Z is log(X, Y))]
%  [(log(X, Y, Z) :- number(Y), number(Z), var(X), !, X is Y ** Z)]
%  [(log(X, Y, Z) :- number(Z), number(Z), var(Y), !, Y is X ** (1 / Z))]
%  [(log(X, Z) :- number(X), var(Z), !, Z is log(X))]
%  [(log(X, Z) :- number(Z), var(X), !, X is exp(1) ** Z)]
%  [(max(X, Y, Z) :- number(X), number(Y), !, Z is max(X, Y))]
%  [(min(X, Y, Z) :- number(X), number(Y), !, Z is min(X, Y))]
%  [(plus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X + Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X - Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(mult(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X * Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(div(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is Z * Y, equalWithSmallTolerance(X, Ztemp))]
%  [(exp(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is X ** Y, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Y, Z) :- number(X), number(Y), number(Z), !, Ztemp is log(X, Y), equalWithSmallTolerance(Z, Ztemp))]
%  [(minus(X, Y) :- number(X), number(Y), !, Ytemp is -X, equalWithSmallTolerance(Z, Ztemp))]
%  [(log(X, Z) :- number(X), number(Y), !, Ztemp is log(X), equalWithSmallTolerance(Z, Ztemp))]
%  [mode(addList(+willList, #willNumber))]
%  [mode(multiplyList(+willList, #willNumber))]
%  [mode(abs(+willNumber, &willNumber))]
%  [mode(minus(+willNumber, &willNumber))]
%  [mode(plus(+willNumber, +willNumber, &willNumber))]
%  [mode(minus(+willNumber, +willNumber, &willNumber))]
%  [mode(mult(+willNumber, +willNumber, &willNumber))]
%  [mode(div(+willNumber, +willNumber, &willNumber))]
%  [mode(allNumbers(+willList))]
%  [mode(positiveNumber(+willNumber))]
%  [mode(negativeNumber(+willNumber))]
%  [mode(in0toDot001(+willNumber))]
%  [mode(in0toDot01(+willNumber))]
%  [mode(in0toDot1(+willNumber))]
%  [mode(in0to1(+willNumber))]
%  [mode(in0to10(+willNumber))]
%  [mode(in0to100(+willNumber))]
%  [mode(in0to1000(+willNumber))]
%  [mode(equalWithTolerance(+willNumber, +willNumber, &willNumber))]
%  [mode(greaterOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(smallerOrEqualDifference(+willNumber, +willNumber, &willNumber))]
%  [mode(isaEqualTolerance(+willNumber))]
%  [mode(lessThan(+willNumber, +willNumber))]
%  [mode(greaterThan(+willNumber, +willNumber))]
%  [mode(lessThanOrEqual(+willNumber, +willNumber))]
%  [mode(greaterThanOrEqual(+willNumber, +willNumber))]
%  [mode(inBetweenOO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCO(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenOC(+willNumber, +willNumber, +willNumber))]
%  [mode(inBetweenCC(+willNumber, +willNumber, +willNumber))]
%  [(member(X, Y) :- ground(X), ground(Y), !, contains(X, Y))]
%  [member(X, [X| _])]
%  [(member(X, [_| Y]) :- member(X, Y))]
%  [(contains(X, [X| _]) :- !)]
%  [(contains(X, [_| Y]) :- contains(X, Y))]
%  [(memberOfList(X, List) :- list(List), member(X, List))]
%  [positionInList(X, [X| _], 0)]
%  [(positionInList(X, List, N) :- list(List), N is position(X, List))]
%  [(firstInList(First, List) :- list(List), First is first(List))]
%  [(restOfList(Rest, List) :- list(List), Rest is rest(List))]
%  [(nthInList(N, List, Result) :- number(N), list(List), Result is nth(N, List))]
%  [(lengthOfList(List, N) :- list(List), N is length(List))]
%  [(reverseList(List, A) :- list(List), A is reverse(List))]
%  [(reverseList(A, List) :- list(List), A is reverse(List))]
%  [(pushIntoList(A, List, C) :- list(List), C is push(A, List))]
%  [(removeFromList(A, List, C) :- list(List), C is remove(A, List))]
%  [(appendLists(List1, List2, Result) :- list(List1), list(List2), Result is append(List1, List2))]
%  [union([], B, B)]
%  [(union([A| B], C, [A| ResultOnB]) :- \+(member(A, C)), !, union(B, C, ResultOnB))]
%  [(union([A| B], C, ResultOnB) :- union(B, C, ResultOnB))]
%  [intersection([], _, [])]
%  [(intersection([A| B], C, [A| ResultOnB]) :- member(A, C), !, intersection(B, C, ResultOnB))]
%  [(intersection([A| B], C, ResultOnB) :- intersection(B, C, ResultOnB))]
%  [(alwaysTrue(Index, List, Expression) :- memberOfList(Index, List), \+(call(Expression)), !, fail)]
%  [alwaysTrue(_, _, _)]
%  [(sometimesTrue(Index, List, Expression) :- L is length(List), memberOfList(Index, List), call(Expression), true)]
%  [(neverTrue(Index, List, Expression) :- member(Index, List), call(Expression), !, fail)]
%  [(neverTrue(_, _, _) :- true)]
%  [(evaluateAll(Index, List, Expression) :- memberOfList(Index, List), call(Expression), fail)]
%  [evaluateAll(_, _, _)]
%  [mode(memberOfList(+willAnything, +willList))]
%  [mode(firstInList(+willList, &willAnything))]
%  [mode(restOfList(+willList, &willList))]
%  [mode(positionInList(+willAnything, +willList, &willNumber))]
%  [mode(nthInList(+willNumber, +willList, &willAnything))]
%  [mode(lengthOfList(+willList, &willNumber))]
%  [(mega_posAnd_notNegOr54(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))]
%  [(mega_notPosAnd_negAnd55(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)))]
%  [(single_example_advice58(Anon5223) :- Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225))]
%  [(not_single_example_advice58(Anon5223) :- \+(Column(Anon5225), Row(Anon5227), Length(Anon5227, Anon5229), Base(Anon5223, Anon5231), Height(Anon5223, Anon5233), H(Anon5225, Anon5235), Contains(Anon5223, Anon5227), Contains(Anon5223, Anon5225), SpRel(topleft, Anon5237, Anon5227, Anon5225)))]
%  [(single_piece_advice59(Anon5207) :- Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209))]
%  [(not_single_piece_advice59(Anon5207) :- \+(Column(Anon5209), Row(Anon5211), Length(Anon5211, Anon5213), Base(Anon5207, Anon5215), Height(Anon5207, Anon5217), H(Anon5209, Anon5219), Contains(Anon5207, Anon5211), Contains(Anon5207, Anon5209), SpRel(topleft, Anon5221, Anon5211, Anon5209)))]

% Took 419 milliseconds.
% Executed 595 proofs in 0.04 seconds (14024.35 proofs/sec).
% Performed 2,250 unifications while proving Horn clauses.
