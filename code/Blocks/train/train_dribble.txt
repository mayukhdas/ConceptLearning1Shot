% Running on host: DESKTOP-K98RL7C

% Creating string handler #3.


***** Warning: Do you really want to make string handler #3? *****


% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=0: args[N]=.\Blocks\train/train_pos.txt

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=1: args[N]=.\Blocks\train/train_neg.txt

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=2: args[N]=.\Blocks\train/train_bk.txt

% getInputArgWithDefaultValue: args=[.\Blocks\train/train_pos.txt, .\Blocks\train/train_neg.txt, .\Blocks\train/train_bk.txt, .\Blocks\train/train_facts.txt]
%  for N=3: args[N]=.\Blocks\train/train_facts.txt

% Welcome to the WILL ILP/SRL systems.


% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.
% Reading background theory from dir: null
% Load '../blocks_bk.txt'.

% Switching to VarIndicator = uppercase.

***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****

  loadThisFile: i=0 newName=precomputed.txt sents=[(sameAsNew(Float1, Float4) :- Length(Part, Float1), Base(Shape, Float4), equalWithSmallTolerance(Float1, Float4)), (equalWithToleranceNew(Float3, Float2, Float6) :- Height(Shape, Float3), H(Part, Float2), Float6 is Float3 - Float2)]

***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****

% LoadAllLibraries() called.  Currently loaded libraries: []

%  The Background Rules:

%  mode(Row(+Part))
%  mode(Length(+Part, +Float1))
%  mode(H(+Part, +Float2))
%  mode(Column(+Part))
%  mode(Contains(+Shape, -Part))
%  mode(Base(+Shape, +Float4))
%  mode(Height(+Shape, +Float3))
%  mode(SpRel(&Rel, +Float5, +Part, +Part))
%  mode(Ell(+Shape))
%  mode(sameAsNew(+Float1, +Float4))
%  mode(equalWithToleranceNew(+Float3, +Float2, #Float6))
%  Ell(Shape) :- 
%     sameAsNew(Float1, Float4)
%  Ell(Shape) :- 
%     equalWithToleranceNew(Float3, Float2, Float6)
%  isaInterestingSymbol(X, X) :- 
%     isaInterestingSymbol(X)
%  isaInterestingNumber(X, Y) :- 
%     isaInterestingNumber(Y),
%     equalWithSmallTolerance(X, Y)
%  isaDifferentInterestingSymbol(X, Y) :- 
%     isaInterestingSymbol(X),
%     isaInterestingSymbol(Y),
%     different(X, Y)
%  isaDifferentInterestingNumber(X, Y) :- 
%     isaInterestingNumber(X),
%     isaInterestingNumber(Y),
%     different(X, Y)
%  positiveNumber(X) :- 
%     number(X),
%     X > 0
%  negativeNumber(X) :- 
%     number(X),
%     X < 0
%  in0to1(X) :- 
%     number(X),
%     X >= 0,
%     X <= 1
%  in0to10(X) :- 
%     number(X),
%     X >= 0,
%     X <= 10
%  in0to100(X) :- 
%     number(X),
%     X >= 0,
%     X <= 100
%  in0to1000(X) :- 
%     number(X),
%     X >= 0,
%     X <= 1000
%  in0toDot001(X) :- 
%     number(X),
%     X >= 0,
%     X <= 0.001
%  in0toDot01(X) :- 
%     number(X),
%     X >= 0,
%     X <= 0.01
%  in0toDot1(X) :- 
%     number(X),
%     X >= 0,
%     X <= 0.1
%  greaterOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Temp is abs(X - Y),
%     Temp >= Z
%  greaterOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is abs(X - Y)
%  smallerOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Temp is abs(X - Y),
%     Temp =< Z
%  smallerOrEqualDifference(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is abs(X - Y)
%  sameAs(X, X) :- 
%     !
%  sameAs(X, Y) :- 
%     number(X),
%     number(Y),
%     equalWithSmallTolerance(X, Y),
%     !
%  sameAs([], []) :- 
%     !
%  sameAs([X1| Y1], [X2| Y2]) :- 
%     sameAs(X1, X2),
%     sameAs(Y1, Y2),
%     !
%  different(X, Y) :- 
%     \+(sameAs(X, Y))
%  equalWithSmallTolerance(X, X) :- 
%     !
%  equalWithSmallTolerance(X, Y) :- 
%     number(X),
%     number(Y),
%     !,
%     Scaled is (2 * abs(X - Y)) / ((abs(X) + abs(Y)) + 1.0E-18),
%     Scaled < 1.0E-6
%  safeLog(0, Base, 1) :- 
%     !
%  safeLog(X, Base, Result) :- 
%     number(X),
%     number(Base),
%     Result is log(X, Base)
%  equalWithTolerance(X, Y, Tolerance) :- 
%     number(X),
%     number(Y),
%     isaEqualTolerance(Tolerance),
%     Diff is abs(X - Y),
%     Diff <= Tolerance
%  isaEqualTolerance(X) :- 
%     number(X),
%     X >= 0,
%     !
%  differentWithTolerance(X, Y, Tolerance) :- 
%     number(X),
%     number(Y),
%     isaEqualTolerance(Tolerance),
%     Diff is abs(X - Y),
%     Diff > Tolerance
%  lessThan(X, Y) :- 
%     number(X),
%     number(Y),
%     X < Y
%  greaterThan(X, Y) :- 
%     number(X),
%     number(Y),
%     X > Y
%  lessThanOrEqual(X, Y) :- 
%     number(X),
%     number(Y),
%     X <= Y
%  greaterThanOrEqual(X, Y) :- 
%     number(X),
%     number(Y),
%     X >= Y
%  inBetweenCC(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower <= Middle,
%     Middle <= Upper
%  inBetweenOC(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower < Middle,
%     Middle <= Upper
%  inBetweenCO(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower <= Middle,
%     Middle < Upper
%  inBetweenOO(Lower, Middle, Upper) :- 
%     number(Lower),
%     number(Middle),
%     number(Upper),
%     Lower < Middle,
%     Middle < Upper
%  addList(List, Result) :- 
%     allNumbers(List),
%     addListOfNumbers(List, Result)
%  multiplyList(List, Result) :- 
%     allNumbers(List),
%     multiplyListOfNumbers(List, Result)
%  allNumbers([X| Y]) :- 
%     number(X),
%     allNumbers(Y)
%  abs(X, Y) :- 
%     number(X),
%     var(Y),
%     Y is abs(X)
%  abs(X, Y) :- 
%     number(X),
%     number(Y),
%     Y is abs(X)
%  plus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X + Y
%  plus(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is Z - X
%  plus(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z - Y
%  minus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X - Y
%  minus(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is X - Z
%  minus(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z + Y
%  minus(X, Y) :- 
%     number(X),
%     var(Y),
%     !,
%     Y is -X
%  minus(X, Y) :- 
%     number(Y),
%     var(X),
%     !,
%     X is -Y
%  mult(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X * Y
%  mult(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is Z / X
%  mult(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z / Y
%  div(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X / Y
%  div(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is X / Z
%  div(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z * Y
%  exp(0, _, 0) :- 
%     !
%  exp(_, 0, 1) :- 
%     !
%  exp(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is X ** Y
%  exp(X, Y, Z) :- 
%     number(X),
%     number(Z),
%     var(Y),
%     !,
%     Y is log(Z) / log(X)
%  exp(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Z ** (1 / Y)
%  log(X, _, _) :- 
%     number(X),
%     X <= 0,
%     !,
%     false()
%  log(1, _, 0) :- 
%     !
%  log(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     var(Z),
%     !,
%     Z is log(X, Y)
%  log(X, Y, Z) :- 
%     number(Y),
%     number(Z),
%     var(X),
%     !,
%     X is Y ** Z
%  log(X, Y, Z) :- 
%     number(Z),
%     number(Z),
%     var(Y),
%     !,
%     Y is X ** (1 / Z)
%  log(X, Z) :- 
%     number(X),
%     var(Z),
%     !,
%     Z is log(X)
%  log(X, Z) :- 
%     number(Z),
%     var(X),
%     !,
%     X is exp(1) ** Z
%  max(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     !,
%     Z is max(X, Y)
%  min(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     !,
%     Z is min(X, Y)
%  plus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X + Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  minus(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X - Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  mult(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X * Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  div(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is Z * Y,
%     equalWithSmallTolerance(X, Ztemp)
%  exp(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is X ** Y,
%     equalWithSmallTolerance(Z, Ztemp)
%  log(X, Y, Z) :- 
%     number(X),
%     number(Y),
%     number(Z),
%     !,
%     Ztemp is log(X, Y),
%     equalWithSmallTolerance(Z, Ztemp)
%  minus(X, Y) :- 
%     number(X),
%     number(Y),
%     !,
%     Ytemp is -X,
%     equalWithSmallTolerance(Z, Ztemp)
%  log(X, Z) :- 
%     number(X),
%     number(Y),
%     !,
%     Ztemp is log(X),
%     equalWithSmallTolerance(Z, Ztemp)
%  member(X, Y) :- 
%     ground(X),
%     ground(Y),
%     !,
%     contains(X, Y)
%  member(X, [X| _])
%  member(X, [_| Y]) :- 
%     member(X, Y)
%  contains(X, [X| _]) :- 
%     !
%  contains(X, [_| Y]) :- 
%     contains(X, Y)
%  memberOfList(X, List) :- 
%     list(List),
%     member(X, List)
%  positionInList(X, [X| _], 0)
%  positionInList(X, List, N) :- 
%     list(List),
%     N is position(X, List)
%  firstInList(First, List) :- 
%     list(List),
%     First is first(List)
%  restOfList(Rest, List) :- 
%     list(List),
%     Rest is rest(List)
%  nthInList(N, List, Result) :- 
%     number(N),
%     list(List),
%     Result is nth(N, List)
%  lengthOfList(List, N) :- 
%     list(List),
%     N is length(List)
%  reverseList(List, A) :- 
%     list(List),
%     A is reverse(List)
%  reverseList(A, List) :- 
%     list(List),
%     A is reverse(List)
%  pushIntoList(A, List, C) :- 
%     list(List),
%     C is push(A, List)
%  removeFromList(A, List, C) :- 
%     list(List),
%     C is remove(A, List)
%  appendLists(List1, List2, Result) :- 
%     list(List1),
%     list(List2),
%     Result is append(List1, List2)
%  union([], B, B)
%  union([A| B], C, [A| ResultOnB]) :- 
%     \+(member(A, C)),
%     !,
%     union(B, C, ResultOnB)
%  union([A| B], C, ResultOnB) :- 
%     union(B, C, ResultOnB)
%  intersection([], _, [])
%  intersection([A| B], C, [A| ResultOnB]) :- 
%     member(A, C),
%     !,
%     intersection(B, C, ResultOnB)
%  intersection([A| B], C, ResultOnB) :- 
%     intersection(B, C, ResultOnB)
%  alwaysTrue(Index, List, Expression) :- 
%     memberOfList(Index, List),
%     \+(call(Expression)),
%     !,
%     fail
%  alwaysTrue(_, _, _)
%  sometimesTrue(Index, List, Expression) :- 
%     L is length(List),
%     memberOfList(Index, List),
%     call(Expression),
%     true
%  neverTrue(Index, List, Expression) :- 
%     member(Index, List),
%     call(Expression),
%     !,
%     fail
%  neverTrue(_, _, _) :- 
%     true
%  evaluateAll(Index, List, Expression) :- 
%     memberOfList(Index, List),
%     call(Expression),
%     fail
%  evaluateAll(_, _, _)

%  Read the facts.
%  Have read 20 facts.
% Have read 1 examples from '.\Blocks\train' [.\Blocks\train/train*].
% Have read 2 examples from '.\Blocks\train' [.\Blocks\train/train*].

%  LearnOneClause initialized.

***** Warning: % Should not set minPosCoverage (2.0) to more than the total weight on the positive examples (1.0).  Will use the maximum possible value. *****

% Reading background theory from dir: .\Blocks\train
% Have read the relevance files.


% NEW target:                 Ell(D)
%  targetPred:                Ell/1
%  targetArgTypes:            signature = [const], types = [+Shape]
%  targets:                   [Ell(D)]
%  targetPredicates:          [Ell/1]
%  targetArgSpecs:            [[D[+Shape]]]
%  variablesInTargets:        [[D]]

% Precompute #0's requests: 'precomputed.txt'
%   sameAsNew(Float1, Float4) :- Length(Part, Float1), Base(Shape, Float4), equalWithSmallTolerance(Float1, Float4)
%   equalWithToleranceNew(Float3, Float2, Float6) :- Height(Shape, Float3), H(Part, Float2), Float6 is Float3 - Float2
% Processing precompute file: precomputed.txt
Writing to file: C:\Users\mayuk\Documents\git\ConceptLearningOnion1Shot\code\precomputed.txt
% Loading: precomputed.txt
% Read an additional 1,260 facts from edu.wisc.cs.will.Utils.condor.CondorFileReader@41a2befb.

% Started collecting constants

% Collecting the types of constants.

%   *** WARNING ***  Constant '8' is already marked as being of types = [Float1];
%          type = 'Float4' may be added if not already known.
%  PredicateName = 'Base', from 'Base(s, 8)',
%  which has types = [signature = [const, const], types = [+Shape, +Float4]]
%   Other warnings with this predicate and this new type are not reported in order to keep this printout small.  Use dontComplainAboutMultipleTypes to override.

%   *** WARNING ***  Constant '8' is already marked as being of types = [Float1, Float4];
%          type = 'Float3' may be added if not already known.
%  PredicateName = 'Height', from 'Height(s, 8)',
%  which has types = [signature = [const, const], types = [+Shape, +Float3]]
%   Other warnings with this predicate and this new type are not reported in order to keep this printout small.  Use dontComplainAboutMultipleTypes to override.

% Looking at the training examples to see if any types of new constants can be inferred.
% Time to collect constants: 1 milliseconds
% Time to collect examples: 0 seconds

% Read 1 pos examples and 2 neg examples.
% Time to init learnOneClause: 26 milliseconds

% Initializing fold 0.
%   Number of positive TRAIN examples = 1.
%   Number of negative TRAIN examples = 2.
%   Number of positive EVAL  examples = 0.
%   Number of negative EVAL  examples = 0.
Strength:: STRONGLY_IRRELEVANT

% Skipping over this 'waitHere': Unknown predicate name in advice: sameAsNew/2.
% [AdviceProcessor]  Generated 0 clauses at relevance level STRONGLY_IRRELEVANT.
% Have selected pos example #0 as the next seed: Ell(s)

% Skipping over this 'waitHere': Unknown predicate name in advice: sameAsNew/2.
% [AdviceProcessor]  Generated 0 clauses at relevance level STRONGLY_IRRELEVANT.

% LearnOneClause Parameters:
%   Targets (1):
%    Ell(+Shape)
%  Modes (10):
%    Row(+Part),
%    Length(+Part, +Float1),
%    H(+Part, +Float2),
%    Column(+Part),
%    Contains(+Shape, -Part),
%    Base(+Shape, +Float4),
%    Height(+Shape, +Float3),
%    SpRel(&Rel, +Float5, +Part, +Part),
%    sameAsNew(+Float1, +Float4),
%    equalWithToleranceNew(+Float3, +Float2, #Float6)

% target           = Ell(D)
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.332225): Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]
% Most-general root: Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]  score = 0.332

% Consider expanding [#1 of outerLoop #1_fold0, bodyLen=0] 'Ell(_).  [covers 1.0/1.0 pos, 2.0/2.0 neg]' score=0.3322248136212625
%  At # nodes expanded = 1, |OPEN| = 0.  Pruned 0 variant children.  Sending 1 items to OPEN for evaluation and possible insertion.
% Have created 1 valid-on-seeds descendants.
HERE!*************SCORING - MD, CHECK THIS

% Consider expanding [#2 of outerLoop #1_fold0, bodyLen=0:1] 'Ell(A) :- Contains(A, _).  [covers 1.0/1.0 pos, 2.0/2.0 neg]' score=0.3322147136212625
HERE!*************SCORING - MD, CHECK THIS
% Gleaner: New best node found (score = 0.990079): Ell(A) :- Contains(A, B), Row(B).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
HERE!*************SCORING - MD, CHECK THIS
HERE!*************SCORING - MD, CHECK THIS

% The best node found: Ell(A) :- Contains(A, B), Row(B).  [covers 1.0/1.0 pos, 0.0/2.0 neg]after retraction

% The best node found: Ell(A) :- Contains(A, B), Row(B).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
outerlooper nontree

% On cycle #1, the best clause found is:
%      Ell(A) :- Contains(A, B), Row(B).  [covers 1.0/1.0 pos, 0.0/2.0 neg]
% This clause covers 1 positive examples, of which 1 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.
% The current set of 1 best clauses covers 100.0% of the positive examples and 0.0% of the negatives.}

% ******************************************

% Have stopped ILP's outer loop because have exceeded the minimal fraction (0.9) of positive examples to cover.

% ******************************************

% Finished fold 0 (0.02s):

% Created a total of 5 clauses and expanded 2 of them.
% The collection of best clauses per cycle covers 1 (out of 1) pos and 0 (out of 2) neg examples.

% % 
% % Clauses:

% Ell(A) :- 
%      Contains(A, B), 
%      Row(B). // Clause #1.


  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- Contains(A, B), Row(B))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
  initially:  |falseNegatives| = 1 and |trueNegatives| = 2.
     getWeightedCoverage: apply this clause (Ell(A) :- Contains(A, B), Row(B))
  currently:  |falseNegatives| = 0 and |trueNegatives| = 2.
%%% Cross-Validation Average Scores [Folds = 1]:

%%% Average TRAINING Coverage Score:
%              Actual
%             Pos   Neg Total
% Model Pos     1     0     1
%       Neg     0     2     2
%     Total     1     2

% False Pos mEst  = 0.0100
% False Neg mEst  = 0.0100

% Accuracy  = 0.9934
% Precision = 0.9901
% Recall    = 0.9901
% F(1)      = 0.9901

% Clauses:

Ell(A) :- 
     Contains(A, B), 
     Row(B). // Clause #1.



% Took 3.891 seconds.
% Executed 44 proofs in 0.01 seconds (7032.31 proofs/sec).
% Performed 471 unifications while proving Horn clauses.
